<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2" properties="2.7" jmeter="2.12 r1636949">
  <hashTree>
    <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="Test Plan" enabled="true">
      <stringProp name="TestPlan.comments"></stringProp>
      <boolProp name="TestPlan.functional_mode">false</boolProp>
      <boolProp name="TestPlan.serialize_threadgroups">true</boolProp>
      <elementProp name="TestPlan.user_defined_variables" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
        <collectionProp name="Arguments.arguments"/>
      </elementProp>
      <stringProp name="TestPlan.user_define_classpath"></stringProp>
    </TestPlan>
    <hashTree>
      <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
        <collectionProp name="Arguments.arguments">
          <elementProp name="host" elementType="Argument">
            <stringProp name="Argument.name">host</stringProp>
            <stringProp name="Argument.value">172.30.24.113</stringProp>
            <stringProp name="Argument.desc">Server Domain Name or IP Address</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="port" elementType="Argument">
            <stringProp name="Argument.name">port</stringProp>
            <stringProp name="Argument.value">4409</stringProp>
            <stringProp name="Argument.desc">Server Port which listen for request</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="protocol" elementType="Argument">
            <stringProp name="Argument.name">protocol</stringProp>
            <stringProp name="Argument.value">http</stringProp>
            <stringProp name="Argument.desc">Protocol for sending request</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="path" elementType="Argument">
            <stringProp name="Argument.name">path</stringProp>
            <stringProp name="Argument.value">pretups/rest/common/rest-controller</stringProp>
            <stringProp name="Argument.desc">URL for common rest controller</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="type" elementType="Argument">
            <stringProp name="Argument.name">type</stringProp>
            <stringProp name="Argument.value">SCTPTEMPL</stringProp>
            <stringProp name="Argument.desc">Type for recognizing web service and navigate request for downloading template</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="loginId" elementType="Argument">
            <stringProp name="Argument.name">loginId</stringProp>
            <stringProp name="Argument.value">deepacorp</stringProp>
            <stringProp name="Argument.desc">login id of the user who is performing action</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="password" elementType="Argument">
            <stringProp name="Argument.name">password</stringProp>
            <stringProp name="Argument.value">1357</stringProp>
            <stringProp name="Argument.desc">password of the user who is performing action</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="externalCode" elementType="Argument">
            <stringProp name="Argument.name">externalCode</stringProp>
            <stringProp name="Argument.value"></stringProp>
            <stringProp name="Argument.desc">External code of the user who is  performing operation</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="userLoginID" elementType="Argument">
            <stringProp name="Argument.name">userLoginID</stringProp>
            <stringProp name="Argument.value">deepacorp</stringProp>
            <stringProp name="Argument.desc">Login ID of the user for which action has been taken</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="serviceCode" elementType="Argument">
            <stringProp name="Argument.name">serviceCode</stringProp>
            <stringProp name="Argument.value">RC</stringProp>
            <stringProp name="Argument.desc">Service code of the action</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="fileType" elementType="Argument">
            <stringProp name="Argument.name">fileType</stringProp>
            <stringProp name="Argument.value">CORPORATE</stringProp>
            <stringProp name="Argument.desc">File type which has to process</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="CSV path" elementType="Argument">
            <stringProp name="Argument.name">CSV path</stringProp>
            <stringProp name="Argument.value">C:\SVN Checkout\JMETER_PRETUPS_UPDATED\scripts\testdata</stringProp>
            <stringProp name="Argument.desc">CSV path for Negetive scenario</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="ResultCsvPath" elementType="Argument">
            <stringProp name="Argument.name">ResultCsvPath</stringProp>
            <stringProp name="Argument.value">C:\SVN Checkout\Resultspostgresresult${__time(ddMMyyyyHHmmss,)}.csv</stringProp>
            <stringProp name="Argument.desc">CSV file path for Result File</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="scheduleDate" elementType="Argument">
            <stringProp name="Argument.name">scheduleDate</stringProp>
            <stringProp name="Argument.value">1/12/17</stringProp>
            <stringProp name="Argument.desc">File schedule date</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="frequencyCode" elementType="Argument">
            <stringProp name="Argument.name">frequencyCode</stringProp>
            <stringProp name="Argument.value">DAILY</stringProp>
            <stringProp name="Argument.desc">Frequency of Batch</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="iterations" elementType="Argument">
            <stringProp name="Argument.name">iterations</stringProp>
            <stringProp name="Argument.value">1</stringProp>
            <stringProp name="Argument.desc">Iteration for frequency</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="geoDomainCode" elementType="Argument">
            <stringProp name="Argument.name">geoDomainCode</stringProp>
            <stringProp name="Argument.value">ZAR</stringProp>
            <stringProp name="Argument.desc">Geography Domain Code</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="requestFor" elementType="Argument">
            <stringProp name="Argument.name">requestFor</stringProp>
            <stringProp name="Argument.value">schedule</stringProp>
            <stringProp name="Argument.desc">Type of Action CORPORATE or NORMAL</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="scheduleNow" elementType="Argument">
            <stringProp name="Argument.name">scheduleNow</stringProp>
            <stringProp name="Argument.value">OFF</stringProp>
            <stringProp name="Argument.desc">On in case if batch needs to execute imediatly else Off</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="domainCode" elementType="Argument">
            <stringProp name="Argument.name">domainCode</stringProp>
            <stringProp name="Argument.value">CORP</stringProp>
            <stringProp name="Argument.desc">Domain Code of the User</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="categoryCode" elementType="Argument">
            <stringProp name="Argument.name">categoryCode</stringProp>
            <stringProp name="Argument.value">CORPE</stringProp>
            <stringProp name="Argument.desc">Category code of the User</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="typeUpload" elementType="Argument">
            <stringProp name="Argument.name">typeUpload</stringProp>
            <stringProp name="Argument.value">SCHTOUPFLUP</stringProp>
            <stringProp name="Argument.desc">Type for recognizing web service and navigate request for Batch File UPload</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="statusin" elementType="Argument">
            <stringProp name="Argument.name">statusin</stringProp>
            <stringProp name="Argument.value">IN</stringProp>
            <stringProp name="Argument.desc">Value IN using Query (DO NOT CHANGE IT)</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="viewtype" elementType="Argument">
            <stringProp name="Argument.name">viewtype</stringProp>
            <stringProp name="Argument.value">VIEWSCHRCBATCH2</stringProp>
            <stringProp name="Argument.desc">Type for recognizing web service and navigate request for viewing  Batych Details</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="status" elementType="Argument">
            <stringProp name="Argument.name">status</stringProp>
            <stringProp name="Argument.value">&apos;S&apos;,&apos;C&apos;,&apos;E&apos;,&apos;U&apos;</stringProp>
            <stringProp name="Argument.desc">Different status of Batch S= Scheduled, C= Cancel, E= Executed, U=Updated</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="cancelType" elementType="Argument">
            <stringProp name="Argument.name">cancelType</stringProp>
            <stringProp name="Argument.value">CANCELMSISDN</stringProp>
            <stringProp name="Argument.desc">Type for recognizing web service and navigate request for CANCEL MSISDN from Batch</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="ViewScheduleType" elementType="Argument">
            <stringProp name="Argument.name">ViewScheduleType</stringProp>
            <stringProp name="Argument.value">VIEWSUBSSCHEDULE</stringProp>
            <stringProp name="Argument.desc">Type for recognizing web service and navigate request for viewing MSIDN schedule details form Batch</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="ResultCsvPathBatchSchedulePositive" elementType="Argument">
            <stringProp name="Argument.name">ResultCsvPathBatchSchedulePositive</stringProp>
            <stringProp name="Argument.value">Q:\Jmeter7.1\Jmeter_Result/result${__time(ddMMyyyyHHmmss,)}.csv</stringProp>
            <stringProp name="Argument.desc">result csv for view schedule reharge in batch</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="ResultCsvPathBatchScheduleNegative" elementType="Argument">
            <stringProp name="Argument.name">ResultCsvPathBatchScheduleNegative</stringProp>
            <stringProp name="Argument.value">Q:\Jmeter7.1\Jmeter_Result/result${__time(ddMMyyyyHHmmss,)}.csv</stringProp>
            <stringProp name="Argument.desc">result csv for view schedule reharge in batch</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="ResultCsvPathViewSchedulePositive" elementType="Argument">
            <stringProp name="Argument.name">ResultCsvPathViewSchedulePositive</stringProp>
            <stringProp name="Argument.value">Q:\Jmeter7.1\Jmeter_Result/result${__time(ddMMyyyyHHmmss,)}.csv</stringProp>
            <stringProp name="Argument.desc">result csv for view schedule reharge </stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="ResultCsvPathViewScheduleNegative" elementType="Argument">
            <stringProp name="Argument.name">ResultCsvPathViewScheduleNegative</stringProp>
            <stringProp name="Argument.value">Q:\Jmeter7.1\Jmeter_Result/result${__time(ddMMyyyyHHmmss,)}.csv</stringProp>
            <stringProp name="Argument.desc">result csv for view schedule reharge </stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="ResultCsvPathBatchIDScheduleNegative" elementType="Argument">
            <stringProp name="Argument.name">ResultCsvPathBatchIDScheduleNegative</stringProp>
            <stringProp name="Argument.value">Q:\Jmeter7.1\Jmeter_Result/result${__time(ddMMyyyyHHmmss,)}.csv</stringProp>
            <stringProp name="Argument.desc">result csv for view schedule reharge in batch</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="cancelBatchDetailType" elementType="Argument">
            <stringProp name="Argument.name">cancelBatchDetailType</stringProp>
            <stringProp name="Argument.value">VIEWCANCEL</stringProp>
            <stringProp name="Argument.desc">Type for recognizing web service and navigate request for viewing Cancel BatchDetails</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="viewcancelMSISDNType" elementType="Argument">
            <stringProp name="Argument.name">viewcancelMSISDNType</stringProp>
            <stringProp name="Argument.value">VIEWCANCELMSISDN</stringProp>
            <stringProp name="Argument.desc">Type for recognizing web service and navigate request for viewing Cancel MSISDN in Batch</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="scheduleFromDate" elementType="Argument">
            <stringProp name="Argument.name">scheduleFromDate</stringProp>
            <stringProp name="Argument.value">01/12/17</stringProp>
            <stringProp name="Argument.desc">From date to filter scheduled Batch</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="scheduleToDate" elementType="Argument">
            <stringProp name="Argument.name">scheduleToDate</stringProp>
            <stringProp name="Argument.value">31/12/17</stringProp>
            <stringProp name="Argument.desc">To date to filter scheduled Batch</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="viewtypebatchid" elementType="Argument">
            <stringProp name="Argument.name">viewtypebatchid</stringProp>
            <stringProp name="Argument.value">VIEWSCHRCBATCH</stringProp>
            <stringProp name="Argument.desc">Type for recognizing web service and navigate request for Viewing list of Batch</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="selectedStatus" elementType="Argument">
            <stringProp name="Argument.name">selectedStatus</stringProp>
            <stringProp name="Argument.value">&apos;S&apos;</stringProp>
            <stringProp name="Argument.desc">Status for filtering Executed Schedule</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="cancelBatch" elementType="Argument">
            <stringProp name="Argument.name">cancelBatch</stringProp>
            <stringProp name="Argument.value">CANCELBATCH</stringProp>
            <stringProp name="Argument.desc">Type for recognizing web service and navigate request for Cancel Batch</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="USER_ID" elementType="Argument">
            <stringProp name="Argument.name">USER_ID</stringProp>
            <stringProp name="Argument.value">NGCO0000000013</stringProp>
            <stringProp name="Argument.desc">UserID of Corporate User</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="ResultXlsPath" elementType="Argument">
            <stringProp name="Argument.name">ResultXlsPath</stringProp>
            <stringProp name="Argument.value">C:\SVN Checkout\Resultspostgres/result${__time(ddMMyyyyHHmmss,)}.xlsx</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="User name" elementType="Argument">
            <stringProp name="Argument.name">User name</stringProp>
            <stringProp name="Argument.value">pretups70</stringProp>
            <stringProp name="Argument.desc">Server user name</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="Password" elementType="Argument">
            <stringProp name="Argument.name">Password</stringProp>
            <stringProp name="Argument.value">pretups123</stringProp>
            <stringProp name="Argument.desc">Server password</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="Database Driver" elementType="Argument">
            <stringProp name="Argument.name">Database Driver</stringProp>
            <stringProp name="Argument.value">org.postgresql.Driver</stringProp>
            <stringProp name="Argument.desc">FOR POSTGRES Database Driver=org.postgresql.Driver FOR ORACLE Database Driver= oracle.jdbc.driver.OracleDriver</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="Database URL" elementType="Argument">
            <stringProp name="Argument.name">Database URL</stringProp>
            <stringProp name="Argument.value">jdbc:postgresql://172.30.24.113:5432/pretups71</stringProp>
            <stringProp name="Argument.desc">Database URL Configuration base on DB FOR POSTGRES jdbc:postgresql://[172.30.20.30]:5432/pretups670_dev_itr2 FOR ORACLE:: jdbc:oracle:thin:@//172.16.11.121:1522/test12c</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="Database User name" elementType="Argument">
            <stringProp name="Argument.name">Database User name</stringProp>
            <stringProp name="Argument.value">pgdb</stringProp>
            <stringProp name="Argument.desc">Database User name</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="Database Password" elementType="Argument">
            <stringProp name="Argument.name">Database Password</stringProp>
            <stringProp name="Argument.value">pgdb</stringProp>
            <stringProp name="Argument.desc">Database Password</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="SVNRepositoryID" elementType="Argument">
            <stringProp name="Argument.name">SVNRepositoryID</stringProp>
            <stringProp name="Argument.value">http://172.16.10.134/CRM/MFS/PreTUPS5x_NG/Base Versions/PreTUPS_trunk/Code/Work/JMETER/JMETER_PRETUPS_UPDATED/scripts/testscript</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="LeadName" elementType="Argument">
            <stringProp name="Argument.name">LeadName</stringProp>
            <stringProp name="Argument.value">Shishupal Singh</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="TestFrameworkIP" elementType="Argument">
            <stringProp name="Argument.name">TestFrameworkIP</stringProp>
            <stringProp name="Argument.value">172.16.11.120</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="TestFrameworkName" elementType="Argument">
            <stringProp name="Argument.name">TestFrameworkName</stringProp>
            <stringProp name="Argument.value">JMeter</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="TestFrameworkSVNPath" elementType="Argument">
            <stringProp name="Argument.name">TestFrameworkSVNPath</stringProp>
            <stringProp name="Argument.value">http://172.16.10.134/CRM/MFS/PreTUPS5x_NG/Base Versions/PreTUPS_trunk/Code/Work/JMETER/JMETER_PRETUPS_UPDATED/scripts/testscript</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="TestExecutionDateTime" elementType="Argument">
            <stringProp name="Argument.name">TestExecutionDateTime</stringProp>
            <stringProp name="Argument.value">${__time(yyyy/MM/dd HH:mm:ss,)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="ProductInterface" elementType="Argument">
            <stringProp name="Argument.name">ProductInterface</stringProp>
            <stringProp name="Argument.value">WEB</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
        </collectionProp>
      </Arguments>
      <hashTree/>
      <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
        <collectionProp name="HeaderManager.headers">
          <elementProp name="" elementType="Header">
            <stringProp name="Header.name">content-type</stringProp>
            <stringProp name="Header.value">application/json</stringProp>
          </elementProp>
          <elementProp name="" elementType="Header">
            <stringProp name="Header.name">accept</stringProp>
            <stringProp name="Header.value">application/json</stringProp>
          </elementProp>
        </collectionProp>
      </HeaderManager>
      <hashTree/>
      <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Results Tree" enabled="true">
        <boolProp name="ResultCollector.error_logging">false</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
            <dataType>true</dataType>
            <encoding>false</encoding>
            <assertions>true</assertions>
            <subresults>true</subresults>
            <responseData>false</responseData>
            <samplerData>false</samplerData>
            <xml>false</xml>
            <fieldNames>false</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <bytes>true</bytes>
            <threadCounts>true</threadCounts>
          </value>
        </objProp>
        <stringProp name="filename"></stringProp>
      </ResultCollector>
      <hashTree/>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Header" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <longProp name="ThreadGroup.start_time">1480673579000</longProp>
        <longProp name="ThreadGroup.end_time">1480673579000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <JDBCDataSource guiclass="TestBeanGUI" testclass="JDBCDataSource" testname="JDBC Connection Configuration" enabled="true">
          <stringProp name="dataSource">O2CTransferRule</stringProp>
          <stringProp name="poolMax">10</stringProp>
          <stringProp name="timeout">10000</stringProp>
          <stringProp name="trimInterval">60000</stringProp>
          <boolProp name="autocommit">true</boolProp>
          <stringProp name="transactionIsolation">DEFAULT</stringProp>
          <boolProp name="keepAlive">true</boolProp>
          <stringProp name="connectionAge">5000</stringProp>
          <stringProp name="checkQuery">Select 1</stringProp>
          <stringProp name="dbUrl">${Database URL}</stringProp>
          <stringProp name="driver">${Database Driver}</stringProp>
          <stringProp name="username">${Database User name}</stringProp>
          <stringProp name="password">${Database Password}</stringProp>
        </JDBCDataSource>
        <hashTree/>
        <org.apache.jmeter.protocol.ssh.sampler.SSHSampler guiclass="TestBeanGUI" testclass="org.apache.jmeter.protocol.ssh.sampler.SSHSampler" testname="Create folder for Catalina" enabled="true">
          <stringProp name="hostname">${Host name}</stringProp>
          <intProp name="port">22</intProp>
          <stringProp name="username">${User name}</stringProp>
          <stringProp name="password">${Password}</stringProp>
          <stringProp name="command">mkdir ${MessageSent Logs path}/${JFolder}</stringProp>
        </org.apache.jmeter.protocol.ssh.sampler.SSHSampler>
        <hashTree>
          <DebugPostProcessor guiclass="TestBeanGUI" testclass="DebugPostProcessor" testname="Debug PostProcessor" enabled="true">
            <boolProp name="displayJMeterProperties">false</boolProp>
            <boolProp name="displayJMeterVariables">true</boolProp>
            <boolProp name="displaySamplerProperties">true</boolProp>
            <boolProp name="displaySystemProperties">false</boolProp>
          </DebugPostProcessor>
          <hashTree/>
        </hashTree>
        <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Header for Result file" enabled="true"/>
        <hashTree>
          <BeanShellSampler guiclass="BeanShellSamplerGui" testclass="BeanShellSampler" testname="BeanShell Sampler" enabled="true">
            <stringProp name="BeanShellSampler.query">//log.info(&quot;DUMPED POST PROCESSOR&quot;);</stringProp>
            <stringProp name="BeanShellSampler.filename"></stringProp>
            <stringProp name="BeanShellSampler.parameters"></stringProp>
            <boolProp name="BeanShellSampler.resetInterpreter">false</boolProp>
          </BeanShellSampler>
          <hashTree/>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import org.apache.jmeter.util.JMeterUtils;
log.info(&quot;...............trying to execute 0............&quot;);
try{String value=JMeterUtils.getPropDefault(&quot;name&quot;,&quot;&quot;);
log.info(&quot;Define User Variables&quot; +vars.get(&quot;CsvTestCaseID&quot;));
log.info(&quot;POST PROCESSOR&quot;);
String resultcsvpath = vars.get(&quot;ResultCsvPath&quot;);
log.info(&quot;DUMPED POST PROCESSOR&quot; + resultcsvpath);

f = new FileOutputStream(resultcsvpath,  true);
p = new PrintStream(f); 
this.interpreter.setOut(p); 
//--&gt; writing data
//print(&quot;\&quot;&quot;+_TestCaseID+&quot;\&quot;,\&quot;&quot;+_Description+&quot;\&quot;,\&quot;&quot;+_Request+&quot;\&quot;,\&quot;&quot;+_Response+&quot;\&quot;,\&quot;&quot;+_Pre_Processed+&quot;\&quot;,\&quot;&quot;+_Post_process+&quot;\&quot;,\&quot;&quot;+_Messages+&quot;\&quot;,\&quot;&quot;+_DumpData+&quot;\&quot;&quot;);
log.info(&quot;...............trying to write............&quot;);
print(&quot;SVN-Repository-ID|Lead-Name|Test-Framework-IP|Test-Framework-Name|Test-Framework-SVN-Path|Test-Execution-Date-Time|Product-Interface|Unique-TestCase-ID|Module|Test-Case-Description|Request|Response|Data|SMS1|SMS2|Test-Status|Analysis&quot;);
//print(&quot;Test case ID\tModule\tDescription\tRequest\tResponse\tData\tSMS1\tSMS2\tStatus&quot;);
/*String OldT = &quot;Lokesh&quot; ;
//vars.get(&quot;asjlkdfjasdjkl&quot;); // I need to compare the value of OldT  
                                 // with ${so_tid_1} which is an exact 
                                 // string and not a variable
if (OldT.equals(_Response)){ 
     print(&quot;Message content matched&quot;);
 }
 else {print(&quot;Message content doesn&apos;t matched&quot;);}*/


f.close(); // close the file
// ------
}
catch(Exception ex) { 
	System.out.println(&quot;Still not working&quot;);
	log.info(ex);}
</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <DebugPostProcessor guiclass="TestBeanGUI" testclass="DebugPostProcessor" testname="Debug PostProcessor" enabled="true">
            <boolProp name="displayJMeterProperties">false</boolProp>
            <boolProp name="displayJMeterVariables">true</boolProp>
            <boolProp name="displaySamplerProperties">true</boolProp>
            <boolProp name="displaySystemProperties">false</boolProp>
          </DebugPostProcessor>
          <hashTree/>
        </hashTree>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Batch Schedule Recharge Template Donwload Positive Scenario" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <longProp name="ThreadGroup.start_time">1481523581000</longProp>
        <longProp name="ThreadGroup.end_time">1481523581000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
          <collectionProp name="Arguments.arguments">
            <elementProp name="CsvSMS1" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS1</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="CsvSMS2" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS2</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="ErrorCode" elementType="Argument">
              <stringProp name="Argument.name">ErrorCode</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="Analysis" elementType="Argument">
              <stringProp name="Argument.name">Analysis</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
          </collectionProp>
        </Arguments>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Template Download Positive Scenario" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;loginId&quot;:&quot;${loginId}&quot;,&quot;password&quot;:&quot;${password}&quot;,&quot;data&quot;:{&quot;loginId&quot;:&quot;${userLoginID}&quot;,&quot;serviceCode&quot;:&quot;${serviceCode}&quot;,&quot;fileType&quot;:&quot;${fileType}&quot;},&quot;type&quot;:&quot;${type}&quot;,&quot;externalCode&quot;:&quot;${externalCode}&quot;}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${host}</stringProp>
          <stringProp name="HTTPSampler.port">${port}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol">${protocol}</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${path}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree/>
        <CSVDataSet guiclass="TestBeanGUI" testclass="CSVDataSet" testname="CSV Data set config" enabled="true">
          <stringProp name="filename">${CSV path}/BATCH_SCHEDULE_RECHARGE_TEMPLATE_DOWNLOAD_POSITIVE.csv</stringProp>
          <stringProp name="fileEncoding"></stringProp>
          <stringProp name="variableNames"></stringProp>
          <stringProp name="delimiter">,</stringProp>
          <boolProp name="quotedData">false</boolProp>
          <boolProp name="recycle">true</boolProp>
          <boolProp name="stopThread">false</boolProp>
          <stringProp name="shareMode">shareMode.all</stringProp>
        </CSVDataSet>
        <hashTree/>
        <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Request Reqder" enabled="true">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">//-- SKD
// -- updating the valiables
var sampler = ctx.getCurrentSampler();
var Arguments = sampler.getArguments();
vars.put(&quot;CsvRequest&quot;,&quot;Request&quot;+Arguments);</stringProp>
        </BeanShellPreProcessor>
        <hashTree/>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Result Writer" enabled="true">
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="script">import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
String jsonString = prev.getResponseDataAsString();

JSONObject jsonObject = new JSONObject();
JSONParser jsonParser = new JSONParser();

jsonObject = (JSONObject) jsonParser.parse(jsonString);
String statusCodeReq = jsonObject.get(&quot;statusCode&quot;).toString();
String status = jsonObject.get(&quot;status&quot;).toString();
String statusCode = &quot;&quot;;
if(statusCodeReq.equalsIgnoreCase(&quot;200&quot;) &amp;&amp; status.equalsIgnoreCase(&quot;true&quot;)){
	statusCode = &quot;Pass&quot;;
}else{
	statusCode = &quot;Fail&quot;;
}

String TestCaseID = vars.get(&quot;TestcaseId&quot;);//argument name must be same as defined in csv file
String Module = vars.get(&quot;Module&quot;);//argument name must be same as defined in csv file
String Description = vars.get(&quot;Description&quot;);//argument name must be same as defined in csv file
String CsvRequest = vars.get(&quot;CsvRequest&quot;);
String SVNRepositoryID = vars.get(&quot;SVNRepositoryID&quot;);
String LeadName = vars.get(&quot;LeadName&quot;);
String TestFrameworkIP = vars.get(&quot;TestFrameworkIP&quot;);
String TestFrameworkName = vars.get(&quot;TestFrameworkName&quot;);
String TestFrameworkSVNPath = vars.get(&quot;TestFrameworkSVNPath&quot;);
String TestExecutionDateTime = vars.get(&quot;TestExecutionDateTime&quot;);
String ProductInterface = vars.get(&quot;ProductInterface&quot;);
String CsvSMS1 = vars.get(&quot;CsvSMS1&quot;);
String CsvSMS2 = vars.get(&quot;CsvSMS2&quot;);
String ErrorCode= vars.get(&quot;ErrorCode&quot;);
String Analysis= vars.get(&quot;Analysis&quot;);
String DumpData= vars.get(&quot;DumpData&quot;);

log.info(SVNRepositoryID);
log.info(LeadName);
log.info(ProductInterface);
PrintData=&quot;&quot;+SVNRepositoryID+&quot;|&quot;+LeadName+&quot;|&quot;+TestFrameworkIP+&quot;|&quot;+TestFrameworkName+&quot;|&quot;+TestFrameworkSVNPath+&quot;|&quot;+TestExecutionDateTime+&quot;|&quot;+ProductInterface+&quot;|&quot;+TestCaseID+&quot;|&quot;+Module+&quot;|&quot;+Description+&quot;|&quot;+CsvRequest+&quot;|&quot;+jsonString+&quot;|&quot;+DumpData+&quot;|&quot;+CsvSMS1+&quot;|&quot;+CsvSMS2+&quot;|&quot;+statusCode+&quot;|&quot;+ErrorCode;


log.info(PrintData);
String resultcsvpath = vars.get(&quot;ResultCsvPath&quot;);
f = new FileOutputStream(resultcsvpath,  true);
p = new PrintStream(f); 
this.interpreter.setOut(p); 
print(PrintData);
f.close();</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Batch Schedule Recharge Template Donwload Negative Scenario" enabled="false">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">11</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <longProp name="ThreadGroup.start_time">1481605017000</longProp>
        <longProp name="ThreadGroup.end_time">1481605017000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
          <collectionProp name="Arguments.arguments">
            <elementProp name="CsvSMS1" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS1</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="CsvSMS2" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS2</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="ErrorCode" elementType="Argument">
              <stringProp name="Argument.name">ErrorCode</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="Analysis" elementType="Argument">
              <stringProp name="Argument.name">Analysis</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
          </collectionProp>
        </Arguments>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Template Download Negetive Scenario" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;loginId&quot;:&quot;${LOGIN_ID}&quot;,&quot;password&quot;:&quot;${PASSWORD}&quot;,&quot;data&quot;:{&quot;loginId&quot;:&quot;${DATA_LOGINID}&quot;,&quot;serviceCode&quot;:&quot;${SERVICE_CODE}&quot;,&quot;fileType&quot;:&quot;${FILE_TYPE}&quot;},&quot;type&quot;:&quot;${TYPE}&quot;,&quot;externalCode&quot;:&quot;${EXTERNAL_CODE}&quot;}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${host}</stringProp>
          <stringProp name="HTTPSampler.port">${port}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol">${protocol}</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${path}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree/>
        <CSVDataSet guiclass="TestBeanGUI" testclass="CSVDataSet" testname="CSV Data set config" enabled="true">
          <stringProp name="filename">${CSV path}/BATCH_SCHEDULE_RECHARGE_TEMPLATE_DOWNLOAD_NEGATIVE.csv</stringProp>
          <stringProp name="fileEncoding"></stringProp>
          <stringProp name="variableNames"></stringProp>
          <stringProp name="delimiter">,</stringProp>
          <boolProp name="quotedData">false</boolProp>
          <boolProp name="recycle">true</boolProp>
          <boolProp name="stopThread">false</boolProp>
          <stringProp name="shareMode">shareMode.all</stringProp>
        </CSVDataSet>
        <hashTree/>
        <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Request Reader" enabled="true">
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="script">//-- SKD
// -- updating the valiables
var sampler = ctx.getCurrentSampler();
var Arguments = sampler.getArguments();
vars.put(&quot;CsvRequest&quot;,&quot;Request&quot;+Arguments);</stringProp>
        </BeanShellPreProcessor>
        <hashTree/>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Result Writer" enabled="true">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;



String jsonString = prev.getResponseDataAsString();

JSONObject jsonObject = new JSONObject();
JSONParser jsonParser = new JSONParser();

jsonObject = (JSONObject) jsonParser.parse(jsonString);
String statusCodeReq = jsonObject.get(&quot;statusCode&quot;).toString();
String status = jsonObject.get(&quot;status&quot;).toString();
String statusCode = &quot;&quot;;
if(statusCodeReq.equalsIgnoreCase(&quot;400&quot;) &amp;&amp; status.equalsIgnoreCase(&quot;false&quot;)){
	statusCode = &quot;Pass&quot;;
}else{
	statusCode = &quot;Fail&quot;;
}

String TestCaseID = vars.get(&quot;TestcaseId&quot;);//argument name must be same as defined in csv file
String Module = vars.get(&quot;Module&quot;);//argument name must be same as defined in csv file
String Description = vars.get(&quot;Description&quot;);//argument name must be same as defined in csv file
String CsvRequest = vars.get(&quot;CsvRequest&quot;);
String SVNRepositoryID = vars.get(&quot;SVNRepositoryID&quot;);
String LeadName = vars.get(&quot;LeadName&quot;);
String TestFrameworkIP = vars.get(&quot;TestFrameworkIP&quot;);
String TestFrameworkName = vars.get(&quot;TestFrameworkName&quot;);
String TestFrameworkSVNPath = vars.get(&quot;TestFrameworkSVNPath&quot;);
String TestExecutionDateTime = vars.get(&quot;TestExecutionDateTime&quot;);
String ProductInterface = vars.get(&quot;ProductInterface&quot;);
String CsvSMS1 = vars.get(&quot;CsvSMS1&quot;);
String CsvSMS2 = vars.get(&quot;CsvSMS2&quot;);
String ErrorCode= vars.get(&quot;ErrorCode&quot;);
String Analysis= vars.get(&quot;Analysis&quot;);
String DumpData= vars.get(&quot;DumpData&quot;);

log.info(SVNRepositoryID);
log.info(LeadName);
log.info(ProductInterface);
PrintData=&quot;&quot;+SVNRepositoryID+&quot;|&quot;+LeadName+&quot;|&quot;+TestFrameworkIP+&quot;|&quot;+TestFrameworkName+&quot;|&quot;+TestFrameworkSVNPath+&quot;|&quot;+TestExecutionDateTime+&quot;|&quot;+ProductInterface+&quot;|&quot;+TestCaseID+&quot;|&quot;+Module+&quot;|&quot;+Description+&quot;|&quot;+CsvRequest+&quot;|&quot;+jsonString+&quot;|&quot;+DumpData+&quot;|&quot;+CsvSMS1+&quot;|&quot;+CsvSMS2+&quot;|&quot;+statusCode+&quot;|&quot;+ErrorCode;

log.info(&quot;%%%%%%%%%%%%%%%%%%%%%%%%&quot;);

log.info(PrintData);
String resultcsvpath = vars.get(&quot;ResultCsvPath&quot;);
f = new FileOutputStream(resultcsvpath,  true);
p = new PrintStream(f); 
this.interpreter.setOut(p); 
print(PrintData);
f.close();</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Batch Schedule Recharge File Uploading Positive Scenario" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <longProp name="ThreadGroup.start_time">1481619822000</longProp>
        <longProp name="ThreadGroup.end_time">1481619822000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
          <collectionProp name="Arguments.arguments">
            <elementProp name="CsvSMS1" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS1</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="CsvSMS2" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS2</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="ErrorCode" elementType="Argument">
              <stringProp name="Argument.name">ErrorCode</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="Analysis" elementType="Argument">
              <stringProp name="Argument.name">Analysis</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
          </collectionProp>
        </Arguments>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="FileTemplate Donwload" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;loginId&quot;:&quot;${loginId}&quot;,&quot;password&quot;:&quot;${password}&quot;,&quot;data&quot;:{&quot;loginId&quot;:&quot;${userLoginID}&quot;,&quot;serviceCode&quot;:&quot;${serviceCode}&quot;,&quot;fileType&quot;:&quot;${fileType}&quot;},&quot;type&quot;:&quot;${type}&quot;,&quot;externalCode&quot;:&quot;${externalCode}&quot;}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${host}</stringProp>
          <stringProp name="HTTPSampler.port">${port}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol">${protocol}</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${path}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <DebugPostProcessor guiclass="TestBeanGUI" testclass="DebugPostProcessor" testname="Debug PostProcessor" enabled="true">
            <boolProp name="displayJMeterProperties">false</boolProp>
            <boolProp name="displayJMeterVariables">true</boolProp>
            <boolProp name="displaySamplerProperties">true</boolProp>
            <boolProp name="displaySystemProperties">false</boolProp>
          </DebugPostProcessor>
          <hashTree/>
        </hashTree>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Result Writer" enabled="true">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Matcher;

import com.univocity.parsers.common.processor.RowListProcessor;
import com.univocity.parsers.csv.CsvParser;
import com.univocity.parsers.csv.CsvParserSettings;
import com.univocity.parsers.csv.CsvWriter;
import com.univocity.parsers.csv.CsvWriterSettings;

JSONObject jsonObject = new JSONObject();
JSONParser jsonParser = new JSONParser();

String jsonString = prev.getResponseDataAsString();

jsonObject = (JSONObject) jsonParser.parse(jsonString);

vars.put(&quot;statusCode&quot;, jsonObject.get(&quot;statusCode&quot;).toString());
vars.put(&quot;status&quot;, jsonObject.get(&quot;status&quot;).toString());


if(vars.get(&quot;statusCode&quot;).equalsIgnoreCase(&quot;200&quot;) &amp;&amp; vars.get(&quot;status&quot;).equalsIgnoreCase(&quot;true&quot;)){
	log.info(&quot;File Path is &gt;&gt;&gt; &quot; + jsonObject.get(&quot;dataObject&quot;).toString());
	String command = &quot;chmod 777 &quot; + jsonObject.get(&quot;dataObject&quot;).toString();
	Runtime.getRuntime().exec(command);
	vars.put(&quot;downloadedTemplatePath&quot;, jsonObject.get(&quot;dataObject&quot;).toString());
}else{
	log.info(jsonObject.get(&quot;formError&quot;).toString());
}

FileReader fileReader = new FileReader(vars.get(&quot;downloadedTemplatePath&quot;).toString());
CsvParserSettings parserSettings = new CsvParserSettings();
parserSettings.setLineSeparatorDetectionEnabled(true);

RowListProcessor processor = new RowListProcessor();
parserSettings.setProcessor(processor);
//parserSettings.setHeaderExtractionEnabled(true);
parserSettings.setSkipEmptyLines(false);
parserSettings.setNumberOfRowsToSkip(2);
CsvParser parser = new CsvParser(parserSettings);
parser.parse(fileReader);
List rows = new ArrayList();
rows = processor.getRows();

log.info(&quot;Total no of rows is &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot; + rows.size().toString());
int i = Integer.parseInt(rows.size().toString());
int totalRow = i-2;

log.info(&quot;Total Reocrds -- &quot; + totalRow);
vars.put(&quot;NOOFRECORDS&quot;,rows.size().toString());
log.info(&quot;%%%%%%%%%%%%%%%% &quot; + vars.get(&quot;downloadedTemplatePath&quot;).toString());
String path = vars.get(&quot;downloadedTemplatePath&quot;).toString().replaceAll(&quot;(\\\\+|/+)&quot;, &quot;/&quot;);
log.info(&quot;$$$$$$$$$$$$$$$$$$$ &quot; + path.toString());
vars.put(&quot;INPUTFILE&quot;,path.toString());
File outputFile = new File(vars.get(&quot;downloadedTemplatePath&quot;).toString());

List finalData = new ArrayList();

for (int k = 0; k&lt; rows.size(); k++) {
	String[] row = (String[])rows.get(k);
	int length = row.length+1;
	String[] data = new String[length];
	int min = Integer.parseInt(row[3]);
	int max = Integer.parseInt(row[4]);
	for (int i = 0; i &lt; row.length; i++) {
		data[i] = row[i];
	}
				
	int amount = min + (int)(Math.random() * ((max - min) + 1));
	data[row.length] = Integer.toString(amount);
	finalData.add(data);
}


String[] header = new String[]{&quot;Mobile number*&quot;,&quot;Subscriber ID*&quot;,&quot;Subscriber name*&quot;,&quot;Minimum transaction amount*&quot;,&quot;Maximum transaction amount*&quot;,&quot;Monthly limit*&quot;,&quot;Used limit*&quot;,&quot;Sub-service *&quot;,&quot;Requested amount*&quot;};
String message = &quot;Requested amount field is editable and changes done in any other field would not be reflected.&quot;;

Writer writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outputFile)));
CsvWriterSettings settings = new CsvWriterSettings();
CsvWriter csvWriter = new CsvWriter(writer, settings);
csvWriter.writeRow(message.toString());
StringBuilder row = new StringBuilder();
for (String column : header) {
	if (row.length() &gt; 0) {
		row.append(&quot;,&quot;);
	}
	row.append(column);
}
csvWriter.writeRow(row.toString());

for (String[] object : finalData) {
	StringBuilder row2 = new StringBuilder();
	for (String column : object) {
		if (row2.length() &gt; 0) {
			row2.append(&quot;,&quot;);
		}
		row2.append(column);
	}
	csvWriter.writeRow(row2.toString());
}

csvWriter.close();
String inputFileString = vars.get(&quot;downloadedTemplatePath&quot;).toString().replace(&quot;\\&quot;, &quot;/&quot;);
vars.put(&quot;inputFile&quot;, inputFileString);
vars.put(&quot;noOfRecords&quot;, rows.size().toString());</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="NoOfRecords" enabled="true">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">${__setProperty(NOOFRECORDS,${NOOFRECORDS})};
</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="InputFilePath" enabled="true">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">${__setProperty(INPUTFILE,${INPUTFILE})};
</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="File upload http request" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;loginId&quot;:&quot;${loginId}&quot;, &quot;password&quot;:&quot;${password}&quot;, &quot;data&quot;:{&quot;categoryCode&quot;:&quot;${categoryCode}&quot;, &quot;domainCode&quot;:&quot;${domainCode}&quot;, &quot;serviceCode&quot;:&quot;${serviceCode}&quot;,&quot;noOfRecords&quot;:&quot;${NOOFRECORDS}&quot;,&quot;fileType&quot;:&quot;${fileType}&quot;,&quot;scheduleNow&quot;:&quot;${scheduleNow}&quot;,&quot;requestFor&quot;:&quot;${requestFor}&quot;, &quot;loginId&quot;:&quot;${userLoginID}&quot;, &quot;uploadedFileLocation&quot;:&quot;${INPUTFILE}&quot;, &quot;geoDomainCode&quot;:&quot;${geoDomainCode}&quot;,&quot;iterations&quot;:&quot;${iterations}&quot;,&quot;frequencyCode&quot;:&quot;${frequencyCode}&quot;,&quot;scheduleDate&quot;:&quot;${scheduleDate}&quot;}, &quot;externalCode&quot;:&quot;${externalCode}&quot;, &quot;type&quot;:&quot;${typeUpload}&quot;}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${host}</stringProp>
          <stringProp name="HTTPSampler.port">${port}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol">${protocol}</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${path}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <DebugPostProcessor guiclass="TestBeanGUI" testclass="DebugPostProcessor" testname="Debug PostProcessor" enabled="true">
            <boolProp name="displayJMeterProperties">false</boolProp>
            <boolProp name="displayJMeterVariables">true</boolProp>
            <boolProp name="displaySamplerProperties">true</boolProp>
            <boolProp name="displaySystemProperties">false</boolProp>
          </DebugPostProcessor>
          <hashTree/>
        </hashTree>
        <CSVDataSet guiclass="TestBeanGUI" testclass="CSVDataSet" testname="CSV Data set config" enabled="true">
          <stringProp name="filename">${CSV path}/BATCH_SCHEDULE_RECHARGE_FILE_UPLOAD_POSITIVE.csv</stringProp>
          <stringProp name="fileEncoding"></stringProp>
          <stringProp name="variableNames"></stringProp>
          <stringProp name="delimiter">,</stringProp>
          <boolProp name="quotedData">false</boolProp>
          <boolProp name="recycle">true</boolProp>
          <boolProp name="stopThread">false</boolProp>
          <stringProp name="shareMode">shareMode.all</stringProp>
        </CSVDataSet>
        <hashTree/>
        <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Request Reader" enabled="true">
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="script">//-- SKD
// -- updating the valiables
var sampler = ctx.getCurrentSampler();
var Arguments = sampler.getArguments();
vars.put(&quot;CsvRequest&quot;,&quot;Request&quot;+Arguments);</stringProp>
        </BeanShellPreProcessor>
        <hashTree/>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Result Writer" enabled="true">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.JSONArray;


String jsonString = prev.getResponseDataAsString();

JSONObject jsonObject = new JSONObject();
JSONParser jsonParser = new JSONParser();

jsonObject = (JSONObject) jsonParser.parse(jsonString);
String statusCodeReq = jsonObject.get(&quot;statusCode&quot;).toString();
String status = jsonObject.get(&quot;status&quot;).toString();
JSONArray parameters = (JSONArray) jsonObject.get(&quot;parameters&quot;);
String batchID  = &quot;&quot;;
if(parameters.size() == 3){
	batchID = parameters.get(2).toString();
}
if(parameters.size() == 1){
	batchID = parameters.get(0).toString();
}

vars.put(&quot;BATCH&quot;,batchID);
String statusCode = &quot;&quot;;
if(vars.get(&quot;statusCode&quot;).equalsIgnoreCase(&quot;200&quot;) &amp;&amp; vars.get(&quot;status&quot;).equalsIgnoreCase(&quot;true&quot;)){
	statusCode = &quot;Pass&quot;;
}else{
	statusCode = &quot;Fail&quot;;
}


String TestCaseID = vars.get(&quot;TestcaseId&quot;);//argument name must be same as defined in csv file
String Module = vars.get(&quot;Module&quot;);//argument name must be same as defined in csv file
String Description = vars.get(&quot;Description&quot;);//argument name must be same as defined in csv file
String CsvRequest = vars.get(&quot;CsvRequest&quot;);
String SVNRepositoryID = vars.get(&quot;SVNRepositoryID&quot;);
String LeadName = vars.get(&quot;LeadName&quot;);
String TestFrameworkIP = vars.get(&quot;TestFrameworkIP&quot;);
String TestFrameworkName = vars.get(&quot;TestFrameworkName&quot;);
String TestFrameworkSVNPath = vars.get(&quot;TestFrameworkSVNPath&quot;);
String TestExecutionDateTime = vars.get(&quot;TestExecutionDateTime&quot;);
String ProductInterface = vars.get(&quot;ProductInterface&quot;);
String CsvSMS1 = vars.get(&quot;CsvSMS1&quot;);
String CsvSMS2 = vars.get(&quot;CsvSMS2&quot;);
String ErrorCode= vars.get(&quot;ErrorCode&quot;);
String Analysis= vars.get(&quot;Analysis&quot;);
String DumpData= vars.get(&quot;DumpData&quot;);

log.info(SVNRepositoryID);
log.info(LeadName);
log.info(ProductInterface);
PrintData=&quot;&quot;+SVNRepositoryID+&quot;|&quot;+LeadName+&quot;|&quot;+TestFrameworkIP+&quot;|&quot;+TestFrameworkName+&quot;|&quot;+TestFrameworkSVNPath+&quot;|&quot;+TestExecutionDateTime+&quot;|&quot;+ProductInterface+&quot;|&quot;+TestCaseID+&quot;|&quot;+Module+&quot;|&quot;+Description+&quot;|&quot;+CsvRequest+&quot;|&quot;+jsonString+&quot;|&quot;+DumpData+&quot;|&quot;+CsvSMS1+&quot;|&quot;+CsvSMS2+&quot;|&quot;+statusCode+&quot;|&quot;+ErrorCode;


log.info(PrintData);
String resultcsvpath = vars.get(&quot;ResultCsvPath&quot;);
f = new FileOutputStream(resultcsvpath,  true);
p = new PrintStream(f); 
this.interpreter.setOut(p); 
print(PrintData);
f.close();
${__setProperty(&quot;BATCH_ID&quot;,${vars.getObject(&quot;BATCH&quot;)})};</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="GETBATCH" enabled="true">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">${__setProperty(BATCHID,${BATCH})};
</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Batch Schedule Recharge File Uploading Negative Scenario" enabled="false">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">31</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <longProp name="ThreadGroup.start_time">1481619893000</longProp>
        <longProp name="ThreadGroup.end_time">1481619893000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <CSVDataSet guiclass="TestBeanGUI" testclass="CSVDataSet" testname="CSV Data set config" enabled="false">
          <stringProp name="filename">${CSV path}/CANCEL_SCHEDULE_VIEW_BATCH_MSISDN_DETAIL_POSITIVE.csv</stringProp>
          <stringProp name="fileEncoding"></stringProp>
          <stringProp name="variableNames"></stringProp>
          <stringProp name="delimiter">,</stringProp>
          <boolProp name="quotedData">false</boolProp>
          <boolProp name="recycle">true</boolProp>
          <boolProp name="stopThread">false</boolProp>
          <stringProp name="shareMode">shareMode.all</stringProp>
        </CSVDataSet>
        <hashTree/>
        <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
          <collectionProp name="Arguments.arguments">
            <elementProp name="CsvSMS1" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS1</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="CsvSMS2" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS2</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="ErrorCode" elementType="Argument">
              <stringProp name="Argument.name">ErrorCode</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="Analysis" elementType="Argument">
              <stringProp name="Argument.name">Analysis</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
          </collectionProp>
        </Arguments>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="File Upload Http Request" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;loginId&quot;:&quot;${LOGIN_ID}&quot;, &quot;password&quot;:&quot;${PASSWORD}&quot;, &quot;data&quot;:{&quot;categoryCode&quot;:&quot;${CATEGORY_CODE}&quot;, &quot;domainCode&quot;:&quot;${DOMAIN_CODE}&quot;, &quot;serviceCode&quot;:&quot;${SERVICE_CODE}&quot;,&quot;noOfRecords&quot;:&quot;${NO_OF_RECORDS}&quot;,&quot;fileType&quot;:&quot;${FILE_TYPE}&quot;,&quot;scheduleNow&quot;:&quot;${SCHEDULE_NOW}&quot;,&quot;requestFor&quot;:&quot;${REQUEST_FOR}&quot;, &quot;loginId&quot;:&quot;${DATA_LOGINID}&quot;, &quot;uploadedFileLocation&quot;:&quot;${UPLOADED_LOCATION}&quot;, &quot;geoDomainCode&quot;:&quot;${GEO_DOMAIN_CODE}&quot;,&quot;iterations&quot;:&quot;${ITERATIONS}&quot;,&quot;frequencyCode&quot;:&quot;${FREQUENCY_CODE}&quot;,&quot;scheduleDate&quot;:&quot;${SCHEDULE_DATE}&quot;}, &quot;externalCode&quot;:&quot;${EXTERNAL_CODE}&quot;, &quot;type&quot;:&quot;${TYPE}&quot;}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${host}</stringProp>
          <stringProp name="HTTPSampler.port">${port}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol">${protocol}</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${path}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree/>
        <CSVDataSet guiclass="TestBeanGUI" testclass="CSVDataSet" testname="CSV Data set config" enabled="true">
          <stringProp name="filename">${CSV path}/BATCH_SCHEDULE_RECHARGE_FILE_UPLOAD_NEGATIVE.csv</stringProp>
          <stringProp name="fileEncoding"></stringProp>
          <stringProp name="variableNames"></stringProp>
          <stringProp name="delimiter">,</stringProp>
          <boolProp name="quotedData">false</boolProp>
          <boolProp name="recycle">true</boolProp>
          <boolProp name="stopThread">false</boolProp>
          <stringProp name="shareMode">shareMode.all</stringProp>
        </CSVDataSet>
        <hashTree/>
        <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Request Reader" enabled="true">
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="script">//-- SKD
// -- updating the valiables
var sampler = ctx.getCurrentSampler();
var Arguments = sampler.getArguments();
vars.put(&quot;CsvRequest&quot;,&quot;Request&quot;+Arguments);</stringProp>
        </BeanShellPreProcessor>
        <hashTree/>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Result Writer" enabled="true">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;



String jsonString = prev.getResponseDataAsString();

JSONObject jsonObject = new JSONObject();
JSONParser jsonParser = new JSONParser();

jsonObject = (JSONObject) jsonParser.parse(jsonString);
String statusCodeReq = jsonObject.get(&quot;statusCode&quot;).toString();
String status = jsonObject.get(&quot;status&quot;).toString();
String statusCode = &quot;&quot;;
if(statusCodeReq.equalsIgnoreCase(&quot;400&quot;) &amp;&amp; status.equalsIgnoreCase(&quot;false&quot;)){
	statusCode = &quot;Pass&quot;;
}else{
	statusCode = &quot;Fail&quot;;
}


String TestCaseID = vars.get(&quot;TestcaseId&quot;);//argument name must be same as defined in csv file
String Module = vars.get(&quot;Module&quot;);//argument name must be same as defined in csv file
String Description = vars.get(&quot;Description&quot;);//argument name must be same as defined in csv file
String CsvRequest = vars.get(&quot;CsvRequest&quot;);
String SVNRepositoryID = vars.get(&quot;SVNRepositoryID&quot;);
String LeadName = vars.get(&quot;LeadName&quot;);
String TestFrameworkIP = vars.get(&quot;TestFrameworkIP&quot;);
String TestFrameworkName = vars.get(&quot;TestFrameworkName&quot;);
String TestFrameworkSVNPath = vars.get(&quot;TestFrameworkSVNPath&quot;);
String TestExecutionDateTime = vars.get(&quot;TestExecutionDateTime&quot;);
String ProductInterface = vars.get(&quot;ProductInterface&quot;);
String CsvSMS1 = vars.get(&quot;CsvSMS1&quot;);
String CsvSMS2 = vars.get(&quot;CsvSMS2&quot;);
String ErrorCode= vars.get(&quot;ErrorCode&quot;);
String Analysis= vars.get(&quot;Analysis&quot;);
String DumpData= vars.get(&quot;DumpData&quot;);

log.info(SVNRepositoryID);
log.info(LeadName);
log.info(ProductInterface);
PrintData=&quot;&quot;+SVNRepositoryID+&quot;|&quot;+LeadName+&quot;|&quot;+TestFrameworkIP+&quot;|&quot;+TestFrameworkName+&quot;|&quot;+TestFrameworkSVNPath+&quot;|&quot;+TestExecutionDateTime+&quot;|&quot;+ProductInterface+&quot;|&quot;+TestCaseID+&quot;|&quot;+Module+&quot;|&quot;+Description+&quot;|&quot;+CsvRequest+&quot;|&quot;+jsonString+&quot;|&quot;+DumpData+&quot;|&quot;+CsvSMS1+&quot;|&quot;+CsvSMS2+&quot;|&quot;+statusCode+&quot;|&quot;+ErrorCode;

log.info(&quot;%%%%%%%%%%%%%%%%%%%%%%%%&quot;);

log.info(PrintData);
String resultcsvpath = vars.get(&quot;ResultCsvPath&quot;);
f = new FileOutputStream(resultcsvpath,  true);
p = new PrintStream(f); 
this.interpreter.setOut(p); 
print(PrintData);
f.close();</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="View Schedule Recharge Batch Positive Scenario" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">0</stringProp>
        <longProp name="ThreadGroup.start_time">1481619822000</longProp>
        <longProp name="ThreadGroup.end_time">1481619822000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
          <collectionProp name="Arguments.arguments">
            <elementProp name="CsvSMS1" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS1</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="CsvSMS2" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS2</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="ErrorCode" elementType="Argument">
              <stringProp name="Argument.name">ErrorCode</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="Analysis" elementType="Argument">
              <stringProp name="Argument.name">Analysis</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
          </collectionProp>
        </Arguments>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="View Using batchID http request" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;loginId&quot;:&quot;${loginId}&quot;,&quot;password&quot;:&quot;${password}&quot;,&quot;type&quot;:&quot;${viewtype}&quot;,&quot;data&quot;:{&quot;loginId&quot;:&quot;${userLoginID}&quot;,&quot;batchID&quot;:&quot;${__property(BATCHID)}&quot;,&quot;statusin&quot;:&quot;${statusin}&quot;,&quot;status&quot;:&quot;${status}&quot;}}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${host}</stringProp>
          <stringProp name="HTTPSampler.port">${port}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol">${protocol}</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${path}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <XPathExtractor guiclass="XPathExtractorGui" testclass="XPathExtractor" testname="TXNSTATUS" enabled="false">
            <stringProp name="XPathExtractor.default">NOVAL</stringProp>
            <stringProp name="XPathExtractor.refname">MSISDN</stringProp>
            <stringProp name="XPathExtractor.xpathQuery">//*[local-name()=&apos;TXNSTATUS&apos;]/text()</stringProp>
            <boolProp name="XPathExtractor.validate">false</boolProp>
            <boolProp name="XPathExtractor.tolerant">false</boolProp>
            <boolProp name="XPathExtractor.namespace">false</boolProp>
          </XPathExtractor>
          <hashTree/>
          <DebugPostProcessor guiclass="TestBeanGUI" testclass="DebugPostProcessor" testname="Debug PostProcessor" enabled="true">
            <boolProp name="displayJMeterProperties">false</boolProp>
            <boolProp name="displayJMeterVariables">true</boolProp>
            <boolProp name="displaySamplerProperties">true</boolProp>
            <boolProp name="displaySystemProperties">false</boolProp>
          </DebugPostProcessor>
          <hashTree/>
        </hashTree>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Result Writer" enabled="false">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.util.List;
import java.util.ArrayList;

import com.univocity.parsers.common.processor.RowListProcessor;
import com.univocity.parsers.csv.CsvParser;
import com.univocity.parsers.csv.CsvParserSettings;
import com.univocity.parsers.csv.CsvWriter;
import com.univocity.parsers.csv.CsvWriterSettings;

JSONObject jsonObject = new JSONObject();
JSONParser jsonParser = new JSONParser();

String jsonString = prev.getResponseDataAsString();

jsonObject = (JSONObject) jsonParser.parse(jsonString);

vars.put(&quot;statusCode&quot;, jsonObject.get(&quot;statusCode&quot;).toString());
vars.put(&quot;status&quot;, jsonObject.get(&quot;status&quot;).toString());


if(vars.get(&quot;statusCode&quot;).equalsIgnoreCase(&quot;200&quot;) &amp;&amp; vars.get(&quot;status&quot;).equalsIgnoreCase(&quot;true&quot;)){
	log.info(&quot;File Path is &gt;&gt;&gt; &quot; + jsonObject.get(&quot;dataObject&quot;).toString());
	vars.put(&quot;downloadedTemplatePath&quot;, jsonObject.get(&quot;dataObject&quot;).toString());
}else{
	log.info(jsonObject.get(&quot;formError&quot;).toString());
}

FileReader fileReader = new FileReader(vars.get(&quot;downloadedTemplatePath&quot;).toString());
CsvParserSettings parserSettings = new CsvParserSettings();
parserSettings.setLineSeparatorDetectionEnabled(true);

RowListProcessor processor = new RowListProcessor();
parserSettings.setProcessor(processor);
parserSettings.setHeaderExtractionEnabled(true);
parserSettings.setSkipEmptyLines(false);
CsvParser parser = new CsvParser(parserSettings);
parser.parse(fileReader);
List rows = new ArrayList();
rows = processor.getRows();

log.info(&quot;Total no of rows is &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot; + rows.size().toString());

File outputFile = new File(vars.get(&quot;downloadedTemplatePath&quot;).toString());

List finalData = new ArrayList();

for (int k = 0; k&lt; rows.size(); k++) {
	String[] row = (String[])rows.get(k);
	int length = row.length+1;
	String[] data = new String[length];
	int min = Integer.parseInt(row[3]);
	int max = Integer.parseInt(row[4]);
	for (int i = 0; i &lt; row.length; i++) {
		data[i] = row[i];
	}
				
	int amount = min + (int)(Math.random() * ((max - min) + 1));
	data[row.length] = Integer.toString(amount);
	finalData.add(data);
}


String[] header = new String[]{&quot;Mobile number*&quot;,&quot;Subscriber ID*&quot;,&quot;Subscriber name*&quot;,&quot;Minimum transaction amount*&quot;,&quot;Maximum transaction amount*&quot;,&quot;Monthly limit*&quot;,&quot;Used limit*&quot;,&quot;Sub-service *&quot;,&quot;Requested amount*&quot;};
		
Writer writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outputFile)));
CsvWriterSettings settings = new CsvWriterSettings();
CsvWriter csvWriter = new CsvWriter(writer, settings);
StringBuilder row = new StringBuilder();
for (String column : header) {
	if (row.length() &gt; 0) {
		row.append(&quot;,&quot;);
	}
	row.append(column);
}
csvWriter.writeRow(row.toString());

for (String[] object : finalData) {
	StringBuilder row2 = new StringBuilder();
	for (String column : object) {
		if (row2.length() &gt; 0) {
			row2.append(&quot;,&quot;);
		}
		row2.append(column);
	}
	csvWriter.writeRow(row2.toString());
}

csvWriter.close();
String inputFileString = vars.get(&quot;downloadedTemplatePath&quot;).toString().replace(&quot;\\&quot;, &quot;/&quot;);
vars.put(&quot;inputFile&quot;, inputFileString);
vars.put(&quot;noOfRecords&quot;, rows.size().toString());</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
        <CSVDataSet guiclass="TestBeanGUI" testclass="CSVDataSet" testname="CSV Data set config" enabled="true">
          <stringProp name="filename">${CSV path}/VIEW_SCHEDULE_RECHARGE_BATCH_POSITIVE.csv</stringProp>
          <stringProp name="fileEncoding"></stringProp>
          <stringProp name="variableNames"></stringProp>
          <stringProp name="delimiter">,</stringProp>
          <boolProp name="quotedData">false</boolProp>
          <boolProp name="recycle">true</boolProp>
          <boolProp name="stopThread">false</boolProp>
          <stringProp name="shareMode">shareMode.all</stringProp>
        </CSVDataSet>
        <hashTree/>
        <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Request Reader" enabled="true">
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="script">var sampler = ctx.getCurrentSampler();
var Arguments = sampler.getArguments();
vars.put(&quot;CsvRequest&quot;,&quot;Request&quot;+Arguments);</stringProp>
        </BeanShellPreProcessor>
        <hashTree/>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Result Writer" enabled="true">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.JSONArray;
import java.util.Set;
import org.apache.jmeter.util.JMeterUtils;


String jsonString = prev.getResponseDataAsString();

JSONObject jsonObject = new JSONObject();
JSONParser jsonParser = new JSONParser();


jsonObject = (JSONObject) jsonParser.parse(jsonString);
String statusCodeReq = jsonObject.get(&quot;statusCode&quot;).toString();
String status = jsonObject.get(&quot;status&quot;).toString();
JSONObject dataObject =  jsonObject.get(&quot;dataObject&quot;);

Set msisdn=dataObject.keySet();
log.info(msisdn.toArray()[0]);
String msisdnStr = msisdn.toArray()[0].toString();

log.info(msisdnStr);
vars.put(&quot;MSIS&quot;,msisdnStr);
log.info(&quot;##################################&quot;);
String statusCode = &quot;&quot;;
if(statusCodeReq.equalsIgnoreCase(&quot;400&quot;) &amp;&amp; status.equalsIgnoreCase(&quot;false&quot;)){
	statusCode = &quot;Fail&quot;;
}else{
	statusCode = &quot;Pass&quot;;
}
log.info(&quot;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&quot;);




String TestCaseID = vars.get(&quot;TestcaseId&quot;);//argument name must be same as defined in csv file
String Module = vars.get(&quot;Module&quot;);//argument name must be same as defined in csv file
String Description = vars.get(&quot;Description&quot;);//argument name must be same as defined in csv file
String CsvRequest = vars.get(&quot;CsvRequest&quot;);
String SVNRepositoryID = vars.get(&quot;SVNRepositoryID&quot;);
String LeadName = vars.get(&quot;LeadName&quot;);
String TestFrameworkIP = vars.get(&quot;TestFrameworkIP&quot;);
String TestFrameworkName = vars.get(&quot;TestFrameworkName&quot;);
String TestFrameworkSVNPath = vars.get(&quot;TestFrameworkSVNPath&quot;);
String TestExecutionDateTime = vars.get(&quot;TestExecutionDateTime&quot;);
String ProductInterface = vars.get(&quot;ProductInterface&quot;);
String CsvSMS1 = vars.get(&quot;CsvSMS1&quot;);
String CsvSMS2 = vars.get(&quot;CsvSMS2&quot;);
String ErrorCode= vars.get(&quot;ErrorCode&quot;);
String Analysis= vars.get(&quot;Analysis&quot;);
String DumpData= vars.get(&quot;DumpData&quot;);

log.info(SVNRepositoryID);
log.info(LeadName);
log.info(ProductInterface);
PrintData=&quot;&quot;+SVNRepositoryID+&quot;|&quot;+LeadName+&quot;|&quot;+TestFrameworkIP+&quot;|&quot;+TestFrameworkName+&quot;|&quot;+TestFrameworkSVNPath+&quot;|&quot;+TestExecutionDateTime+&quot;|&quot;+ProductInterface+&quot;|&quot;+TestCaseID+&quot;|&quot;+Module+&quot;|&quot;+Description+&quot;|&quot;+CsvRequest+&quot;|&quot;+jsonString+&quot;|&quot;+DumpData+&quot;|&quot;+CsvSMS1+&quot;|&quot;+CsvSMS2+&quot;|&quot;+statusCode+&quot;|&quot;+ErrorCode;


log.info(PrintData);
String resultcsvpath = vars.get(&quot;ResultCsvPath&quot;);
f = new FileOutputStream(resultcsvpath,  true);
p = new PrintStream(f); 
this.interpreter.setOut(p); 
print(PrintData);
f.close();


//JMeterUtils.setProperty(&quot;MSISDN&quot;, ${vars.getObject(&quot;msis&quot;)});
</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="GETMSISDN" enabled="true">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">${__setProperty(MOBILENUMBER,${MSIS})};</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="View Schedule Recharge Batch Negative Scenario" enabled="false">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">8</stringProp>
        <stringProp name="ThreadGroup.ramp_time">16</stringProp>
        <longProp name="ThreadGroup.start_time">1481619822000</longProp>
        <longProp name="ThreadGroup.end_time">1481619822000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
          <collectionProp name="Arguments.arguments">
            <elementProp name="CsvSMS1" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS1</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="CsvSMS2" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS2</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="ErrorCode" elementType="Argument">
              <stringProp name="Argument.name">ErrorCode</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="Analysis" elementType="Argument">
              <stringProp name="Argument.name">Analysis</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
          </collectionProp>
        </Arguments>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="View Using batchID http request" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;loginId&quot;:&quot;${LOGIN_ID}&quot;, &quot;password&quot;:&quot;${PASSWORD}&quot;,&quot;type&quot;:&quot;${TYPE}&quot;, &quot;data&quot;:{ &quot;loginId&quot;:&quot;${DATA_LOGINID}&quot;,  &quot;batchID&quot;:&quot;${BATCHID}&quot;,&quot;statusin&quot;:&quot;${STATUSIN}&quot;,&quot;status&quot;:&quot;${SCH_STATUS}&quot;}}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${host}</stringProp>
          <stringProp name="HTTPSampler.port">${port}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol">${protocol}</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${path}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <XPathExtractor guiclass="XPathExtractorGui" testclass="XPathExtractor" testname="TXNSTATUS" enabled="false">
            <stringProp name="XPathExtractor.default">NOVAL</stringProp>
            <stringProp name="XPathExtractor.refname">MSISDN</stringProp>
            <stringProp name="XPathExtractor.xpathQuery">//*[local-name()=&apos;TXNSTATUS&apos;]/text()</stringProp>
            <boolProp name="XPathExtractor.validate">false</boolProp>
            <boolProp name="XPathExtractor.tolerant">false</boolProp>
            <boolProp name="XPathExtractor.namespace">false</boolProp>
          </XPathExtractor>
          <hashTree/>
          <DebugPostProcessor guiclass="TestBeanGUI" testclass="DebugPostProcessor" testname="Debug PostProcessor" enabled="true">
            <boolProp name="displayJMeterProperties">false</boolProp>
            <boolProp name="displayJMeterVariables">true</boolProp>
            <boolProp name="displaySamplerProperties">true</boolProp>
            <boolProp name="displaySystemProperties">false</boolProp>
          </DebugPostProcessor>
          <hashTree/>
        </hashTree>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Result Writer" enabled="false">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.util.List;
import java.util.ArrayList;

import com.univocity.parsers.common.processor.RowListProcessor;
import com.univocity.parsers.csv.CsvParser;
import com.univocity.parsers.csv.CsvParserSettings;
import com.univocity.parsers.csv.CsvWriter;
import com.univocity.parsers.csv.CsvWriterSettings;

JSONObject jsonObject = new JSONObject();
JSONParser jsonParser = new JSONParser();

String jsonString = prev.getResponseDataAsString();

jsonObject = (JSONObject) jsonParser.parse(jsonString);

vars.put(&quot;statusCode&quot;, jsonObject.get(&quot;statusCode&quot;).toString());
vars.put(&quot;status&quot;, jsonObject.get(&quot;status&quot;).toString());


if(vars.get(&quot;statusCode&quot;).equalsIgnoreCase(&quot;200&quot;) &amp;&amp; vars.get(&quot;status&quot;).equalsIgnoreCase(&quot;true&quot;)){
	log.info(&quot;File Path is &gt;&gt;&gt; &quot; + jsonObject.get(&quot;dataObject&quot;).toString());
	vars.put(&quot;downloadedTemplatePath&quot;, jsonObject.get(&quot;dataObject&quot;).toString());
}else{
	log.info(jsonObject.get(&quot;formError&quot;).toString());
}

FileReader fileReader = new FileReader(vars.get(&quot;downloadedTemplatePath&quot;).toString());
CsvParserSettings parserSettings = new CsvParserSettings();
parserSettings.setLineSeparatorDetectionEnabled(true);

RowListProcessor processor = new RowListProcessor();
parserSettings.setProcessor(processor);
parserSettings.setHeaderExtractionEnabled(true);
parserSettings.setSkipEmptyLines(false);
CsvParser parser = new CsvParser(parserSettings);
parser.parse(fileReader);
List rows = new ArrayList();
rows = processor.getRows();

log.info(&quot;Total no of rows is &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot; + rows.size().toString());

File outputFile = new File(vars.get(&quot;downloadedTemplatePath&quot;).toString());

List finalData = new ArrayList();

for (int k = 0; k&lt; rows.size(); k++) {
	String[] row = (String[])rows.get(k);
	int length = row.length+1;
	String[] data = new String[length];
	int min = Integer.parseInt(row[3]);
	int max = Integer.parseInt(row[4]);
	for (int i = 0; i &lt; row.length; i++) {
		data[i] = row[i];
	}
				
	int amount = min + (int)(Math.random() * ((max - min) + 1));
	data[row.length] = Integer.toString(amount);
	finalData.add(data);
}


String[] header = new String[]{&quot;Mobile number*&quot;,&quot;Subscriber ID*&quot;,&quot;Subscriber name*&quot;,&quot;Minimum transaction amount*&quot;,&quot;Maximum transaction amount*&quot;,&quot;Monthly limit*&quot;,&quot;Used limit*&quot;,&quot;Sub-service *&quot;,&quot;Requested amount*&quot;};
		
Writer writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outputFile)));
CsvWriterSettings settings = new CsvWriterSettings();
CsvWriter csvWriter = new CsvWriter(writer, settings);
StringBuilder row = new StringBuilder();
for (String column : header) {
	if (row.length() &gt; 0) {
		row.append(&quot;,&quot;);
	}
	row.append(column);
}
csvWriter.writeRow(row.toString());

for (String[] object : finalData) {
	StringBuilder row2 = new StringBuilder();
	for (String column : object) {
		if (row2.length() &gt; 0) {
			row2.append(&quot;,&quot;);
		}
		row2.append(column);
	}
	csvWriter.writeRow(row2.toString());
}

csvWriter.close();
String inputFileString = vars.get(&quot;downloadedTemplatePath&quot;).toString().replace(&quot;\\&quot;, &quot;/&quot;);
vars.put(&quot;inputFile&quot;, inputFileString);
vars.put(&quot;noOfRecords&quot;, rows.size().toString());</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
        <CSVDataSet guiclass="TestBeanGUI" testclass="CSVDataSet" testname="CSV Data set config" enabled="true">
          <stringProp name="filename">${CSV path}/VIEW_SCHEDULE_RECHARGE_BATCH_NEGATIVE.csv</stringProp>
          <stringProp name="fileEncoding"></stringProp>
          <stringProp name="variableNames"></stringProp>
          <stringProp name="delimiter">,</stringProp>
          <boolProp name="quotedData">false</boolProp>
          <boolProp name="recycle">true</boolProp>
          <boolProp name="stopThread">false</boolProp>
          <stringProp name="shareMode">shareMode.all</stringProp>
        </CSVDataSet>
        <hashTree/>
        <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Request Reader" enabled="true">
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="script">var sampler = ctx.getCurrentSampler();
var Arguments = sampler.getArguments();
vars.put(&quot;CsvRequest&quot;,&quot;Request&quot;+Arguments);</stringProp>
        </BeanShellPreProcessor>
        <hashTree/>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Result Writer" enabled="true">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.JSONArray;
import java.util.Set;
import org.apache.jmeter.util.JMeterUtils;


String jsonString = prev.getResponseDataAsString();

JSONObject jsonObject = new JSONObject();
JSONParser jsonParser = new JSONParser();

jsonObject = (JSONObject) jsonParser.parse(jsonString);
String statusCodeReq = jsonObject.get(&quot;statusCode&quot;).toString();
String status = jsonObject.get(&quot;status&quot;).toString();
JSONObject dataObject =  jsonObject.get(&quot;dataObject&quot;);

Set msisdn=dataObject.keySet();
log.info(msisdn.toArray()[0]);
vars.put(&quot;MSIS&quot;,msisdn.toArray()[0].toString());

String statusCode = &quot;&quot;;
if(statusCodeReq.equalsIgnoreCase(&quot;400&quot;) &amp;&amp; status.equalsIgnoreCase(&quot;false&quot;)){
	statusCode = &quot;Pass&quot;;
}else{
	statusCode = &quot;Fail&quot;;
}


String TestCaseID = vars.get(&quot;TestcaseId&quot;);//argument name must be same as defined in csv file
String Module = vars.get(&quot;Module&quot;);//argument name must be same as defined in csv file
String Description = vars.get(&quot;Description&quot;);//argument name must be same as defined in csv file
String CsvRequest = vars.get(&quot;CsvRequest&quot;);
String SVNRepositoryID = vars.get(&quot;SVNRepositoryID&quot;);
String LeadName = vars.get(&quot;LeadName&quot;);
String TestFrameworkIP = vars.get(&quot;TestFrameworkIP&quot;);
String TestFrameworkName = vars.get(&quot;TestFrameworkName&quot;);
String TestFrameworkSVNPath = vars.get(&quot;TestFrameworkSVNPath&quot;);
String TestExecutionDateTime = vars.get(&quot;TestExecutionDateTime&quot;);
String ProductInterface = vars.get(&quot;ProductInterface&quot;);
String CsvSMS1 = vars.get(&quot;CsvSMS1&quot;);
String CsvSMS2 = vars.get(&quot;CsvSMS2&quot;);
String ErrorCode= vars.get(&quot;ErrorCode&quot;);
String Analysis= vars.get(&quot;Analysis&quot;);
String DumpData= vars.get(&quot;DumpData&quot;);

log.info(SVNRepositoryID);
log.info(LeadName);
log.info(ProductInterface);
PrintData=&quot;&quot;+SVNRepositoryID+&quot;|&quot;+LeadName+&quot;|&quot;+TestFrameworkIP+&quot;|&quot;+TestFrameworkName+&quot;|&quot;+TestFrameworkSVNPath+&quot;|&quot;+TestExecutionDateTime+&quot;|&quot;+ProductInterface+&quot;|&quot;+TestCaseID+&quot;|&quot;+Module+&quot;|&quot;+Description+&quot;|&quot;+CsvRequest+&quot;|&quot;+jsonString+&quot;|&quot;+DumpData+&quot;|&quot;+CsvSMS1+&quot;|&quot;+CsvSMS2+&quot;|&quot;+statusCode+&quot;|&quot;+ErrorCode;


log.info(PrintData);
String resultcsvpath = vars.get(&quot;ResultCsvPath&quot;);
f = new FileOutputStream(resultcsvpath,  true);
p = new PrintStream(f); 
this.interpreter.setOut(p); 
print(PrintData);
f.close();

</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="View Schedule Recharge Batch Id&apos;s Positive Scenario" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">0</stringProp>
        <longProp name="ThreadGroup.start_time">1481619822000</longProp>
        <longProp name="ThreadGroup.end_time">1481619822000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
          <collectionProp name="Arguments.arguments">
            <elementProp name="CsvSMS1" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS1</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="CsvSMS2" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS2</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="ErrorCode" elementType="Argument">
              <stringProp name="Argument.name">ErrorCode</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="Analysis" elementType="Argument">
              <stringProp name="Argument.name">Analysis</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
          </collectionProp>
        </Arguments>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="View Batch Id&apos;s http request" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;loginId&quot;:&quot;${loginId}&quot;, &quot;password&quot;:&quot;${password}&quot;,&quot;type&quot;:&quot;${viewtypebatchid}&quot;, &quot;data&quot;:{&quot;categoryCode&quot;:&quot;${categoryCode}&quot;,&quot;domainCode&quot;:&quot;${domainCode}&quot;, &quot;loginId&quot;:&quot;${userLoginID}&quot;,&quot;geoDomainCode&quot;:&quot;${geoDomainCode}&quot;,&#xd;
&quot;scheduleFromDate&quot;:&quot;${scheduleFromDate}&quot;,&quot;scheduleToDate&quot;:&quot;${scheduleToDate}&quot;,&quot;statusin&quot;:&quot;${statusin}&quot;,&#xd;
&quot;status&quot;:&quot;${selectedStatus}&quot;}}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${host}</stringProp>
          <stringProp name="HTTPSampler.port">${port}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol">${protocol}</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${path}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <XPathExtractor guiclass="XPathExtractorGui" testclass="XPathExtractor" testname="TXNSTATUS" enabled="false">
            <stringProp name="XPathExtractor.default">NOVAL</stringProp>
            <stringProp name="XPathExtractor.refname">MSISDN</stringProp>
            <stringProp name="XPathExtractor.xpathQuery">//*[local-name()=&apos;TXNSTATUS&apos;]/text()</stringProp>
            <boolProp name="XPathExtractor.validate">false</boolProp>
            <boolProp name="XPathExtractor.tolerant">false</boolProp>
            <boolProp name="XPathExtractor.namespace">false</boolProp>
          </XPathExtractor>
          <hashTree/>
          <DebugPostProcessor guiclass="TestBeanGUI" testclass="DebugPostProcessor" testname="Debug PostProcessor" enabled="true">
            <boolProp name="displayJMeterProperties">false</boolProp>
            <boolProp name="displayJMeterVariables">true</boolProp>
            <boolProp name="displaySamplerProperties">true</boolProp>
            <boolProp name="displaySystemProperties">false</boolProp>
          </DebugPostProcessor>
          <hashTree/>
        </hashTree>
        <CSVDataSet guiclass="TestBeanGUI" testclass="CSVDataSet" testname="CSV Data set config" enabled="true">
          <stringProp name="filename">${CSV path}/VIEW_SCHEDULE_RECHARGE_BATCH_IDS_POSITIVE.csv</stringProp>
          <stringProp name="fileEncoding"></stringProp>
          <stringProp name="variableNames"></stringProp>
          <stringProp name="delimiter">,</stringProp>
          <boolProp name="quotedData">false</boolProp>
          <boolProp name="recycle">true</boolProp>
          <boolProp name="stopThread">false</boolProp>
          <stringProp name="shareMode">shareMode.all</stringProp>
        </CSVDataSet>
        <hashTree/>
        <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Request Reader" enabled="true">
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="script">var sampler = ctx.getCurrentSampler();
var Arguments = sampler.getArguments();
vars.put(&quot;CsvRequest&quot;,&quot;Request&quot;+Arguments);</stringProp>
        </BeanShellPreProcessor>
        <hashTree/>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Result Writer" enabled="true">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.JSONArray;
import java.util.Set;
import org.apache.jmeter.util.JMeterUtils;
log.info(&quot;0000##################################&quot;);
String jsonString = prev.getResponseDataAsString();
log.info(&quot;1000##################################&quot;);
JSONObject jsonObject = new JSONObject();
JSONParser jsonParser = new JSONParser();
log.info(&quot;2000##################################&quot;);

jsonObject = (JSONObject) jsonParser.parse(jsonString);
log.info(&quot;31000##################################&quot;);
String statusCodeReq = jsonObject.get(&quot;statusCode&quot;).toString();
log.info(&quot;32000##################################&quot;);
String status = jsonObject.get(&quot;status&quot;).toString();
log.info(&quot;33000##################################&quot;);
JSONObject dataObject =  jsonObject.get(&quot;dataObject&quot;);

log.info(&quot;3000##################################&quot;);
Set msisdn=dataObject.keySet();
log.info(&quot;1##################################&quot;);
log.info(msisdn.toArray()[0]);
log.info(&quot;12##################################&quot;);
String msisdnStr = msisdn.toArray()[0].toString();
vars.put(&quot;MSIS&quot;, msisdnStr);
log.info(&quot;123##################################&quot;);
String statusCode = &quot;&quot;;
if(statusCodeReq.equalsIgnoreCase(&quot;400&quot;) &amp;&amp; status.equalsIgnoreCase(&quot;false&quot;)){
	statusCode = &quot;Fail&quot;;
}else{
	statusCode = &quot;Pass&quot;;
}


String TestCaseID = vars.get(&quot;TestcaseId&quot;);//argument name must be same as defined in csv file
String Module = vars.get(&quot;Module&quot;);//argument name must be same as defined in csv file
String Description = vars.get(&quot;Description&quot;);//argument name must be same as defined in csv file
String CsvRequest = vars.get(&quot;CsvRequest&quot;);
String SVNRepositoryID = vars.get(&quot;SVNRepositoryID&quot;);
String LeadName = vars.get(&quot;LeadName&quot;);
String TestFrameworkIP = vars.get(&quot;TestFrameworkIP&quot;);
String TestFrameworkName = vars.get(&quot;TestFrameworkName&quot;);
String TestFrameworkSVNPath = vars.get(&quot;TestFrameworkSVNPath&quot;);
String TestExecutionDateTime = vars.get(&quot;TestExecutionDateTime&quot;);
String ProductInterface = vars.get(&quot;ProductInterface&quot;);
String CsvSMS1 = vars.get(&quot;CsvSMS1&quot;);
String CsvSMS2 = vars.get(&quot;CsvSMS2&quot;);
String ErrorCode= vars.get(&quot;ErrorCode&quot;);
String Analysis= vars.get(&quot;Analysis&quot;);
String DumpData= vars.get(&quot;DumpData&quot;);

log.info(SVNRepositoryID);
log.info(LeadName);
log.info(ProductInterface);
PrintData=&quot;&quot;+SVNRepositoryID+&quot;|&quot;+LeadName+&quot;|&quot;+TestFrameworkIP+&quot;|&quot;+TestFrameworkName+&quot;|&quot;+TestFrameworkSVNPath+&quot;|&quot;+TestExecutionDateTime+&quot;|&quot;+ProductInterface+&quot;|&quot;+TestCaseID+&quot;|&quot;+Module+&quot;|&quot;+Description+&quot;|&quot;+CsvRequest+&quot;|&quot;+jsonString+&quot;|&quot;+DumpData+&quot;|&quot;+CsvSMS1+&quot;|&quot;+CsvSMS2+&quot;|&quot;+statusCode+&quot;|&quot;+ErrorCode;


log.info(PrintData);
String resultcsvpath = vars.get(&quot;ResultCsvPath&quot;);
f = new FileOutputStream(resultcsvpath,  true);
p = new PrintStream(f); 
this.interpreter.setOut(p); 
print(PrintData);
f.close();




</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="View Schedule Recharge Batch Id&apos;s Negative Scenario" enabled="false">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">18</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">0</stringProp>
        <longProp name="ThreadGroup.start_time">1481619822000</longProp>
        <longProp name="ThreadGroup.end_time">1481619822000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
          <collectionProp name="Arguments.arguments">
            <elementProp name="CsvSMS1" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS1</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="CsvSMS2" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS2</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="ErrorCode" elementType="Argument">
              <stringProp name="Argument.name">ErrorCode</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="Analysis" elementType="Argument">
              <stringProp name="Argument.name">Analysis</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
          </collectionProp>
        </Arguments>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="View Batch Id&apos;s http request" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;loginId&quot;:&quot;${LOGIN_ID}&quot;, &quot;password&quot;:&quot;${PASSWORD}&quot;,&quot;type&quot;:&quot;${TYPE}&quot;, &quot;data&quot;:{&quot;categoryCode&quot;:&quot;${CATEGORY_CODE}&quot;, &quot;domainCode&quot;:&quot;${DOMAIN_CODE}&quot;, &quot;loginId&quot;:&quot;${DATA_LOGINID}&quot;,  &quot;geoDomainCode&quot;:&quot;${GEO_DOMAIN_CODE}&quot;,&quot;scheduleFromDate&quot;:&quot;${SCHEDULE_FROM_DATE}&quot;,&quot;scheduleToDate&quot;:&quot;${SCHEDULE_TO_DATE}&quot; ,&quot;statusin&quot;:&quot;${STATUSIN}&quot;,&quot;status&quot;:&quot;${SCH_STATUS}&quot;}}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${host}</stringProp>
          <stringProp name="HTTPSampler.port">${port}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol">${protocol}</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${path}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <XPathExtractor guiclass="XPathExtractorGui" testclass="XPathExtractor" testname="TXNSTATUS" enabled="false">
            <stringProp name="XPathExtractor.default">NOVAL</stringProp>
            <stringProp name="XPathExtractor.refname">MSISDN</stringProp>
            <stringProp name="XPathExtractor.xpathQuery">//*[local-name()=&apos;TXNSTATUS&apos;]/text()</stringProp>
            <boolProp name="XPathExtractor.validate">false</boolProp>
            <boolProp name="XPathExtractor.tolerant">false</boolProp>
            <boolProp name="XPathExtractor.namespace">false</boolProp>
          </XPathExtractor>
          <hashTree/>
          <DebugPostProcessor guiclass="TestBeanGUI" testclass="DebugPostProcessor" testname="Debug PostProcessor" enabled="true">
            <boolProp name="displayJMeterProperties">false</boolProp>
            <boolProp name="displayJMeterVariables">true</boolProp>
            <boolProp name="displaySamplerProperties">true</boolProp>
            <boolProp name="displaySystemProperties">false</boolProp>
          </DebugPostProcessor>
          <hashTree/>
        </hashTree>
        <CSVDataSet guiclass="TestBeanGUI" testclass="CSVDataSet" testname="CSV Data set config" enabled="true">
          <stringProp name="filename">${CSV path}/VIEW_SCHEDULE_RECHARGE_BATCH_IDS_NEGATIVE.csv</stringProp>
          <stringProp name="fileEncoding"></stringProp>
          <stringProp name="variableNames"></stringProp>
          <stringProp name="delimiter">,</stringProp>
          <boolProp name="quotedData">false</boolProp>
          <boolProp name="recycle">true</boolProp>
          <boolProp name="stopThread">false</boolProp>
          <stringProp name="shareMode">shareMode.all</stringProp>
        </CSVDataSet>
        <hashTree/>
        <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Request Reader" enabled="true">
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="script">var sampler = ctx.getCurrentSampler();
var Arguments = sampler.getArguments();
vars.put(&quot;CsvRequest&quot;,&quot;Request&quot;+Arguments);</stringProp>
        </BeanShellPreProcessor>
        <hashTree/>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Result Writer" enabled="true">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.JSONArray;

String jsonString = prev.getResponseDataAsString();

JSONObject jsonObject = new JSONObject();
JSONParser jsonParser = new JSONParser();

jsonObject = (JSONObject) jsonParser.parse(jsonString);
String statusCodeReq = jsonObject.get(&quot;statusCode&quot;).toString();
String status = jsonObject.get(&quot;status&quot;).toString();
JSONObject dataObject =  jsonObject.get(&quot;dataObject&quot;);

String statusCode = &quot;&quot;;
if(statusCodeReq.equalsIgnoreCase(&quot;400&quot;) &amp;&amp; status.equalsIgnoreCase(&quot;false&quot;)){
	statusCode = &quot;Pass&quot;;
}else{
	statusCode = &quot;Fail&quot;;
}


String TestCaseID = vars.get(&quot;TestcaseId&quot;);//argument name must be same as defined in csv file
String Module = vars.get(&quot;Module&quot;);//argument name must be same as defined in csv file
String Description = vars.get(&quot;Description&quot;);//argument name must be same as defined in csv file
String CsvRequest = vars.get(&quot;CsvRequest&quot;);
String SVNRepositoryID = vars.get(&quot;SVNRepositoryID&quot;);
String LeadName = vars.get(&quot;LeadName&quot;);
String TestFrameworkIP = vars.get(&quot;TestFrameworkIP&quot;);
String TestFrameworkName = vars.get(&quot;TestFrameworkName&quot;);
String TestFrameworkSVNPath = vars.get(&quot;TestFrameworkSVNPath&quot;);
String TestExecutionDateTime = vars.get(&quot;TestExecutionDateTime&quot;);
String ProductInterface = vars.get(&quot;ProductInterface&quot;);
String CsvSMS1 = vars.get(&quot;CsvSMS1&quot;);
String CsvSMS2 = vars.get(&quot;CsvSMS2&quot;);
String ErrorCode= vars.get(&quot;ErrorCode&quot;);
String Analysis= vars.get(&quot;Analysis&quot;);
String DumpData= vars.get(&quot;DumpData&quot;);

log.info(SVNRepositoryID);
log.info(LeadName);
log.info(ProductInterface);
PrintData=&quot;&quot;+SVNRepositoryID+&quot;|&quot;+LeadName+&quot;|&quot;+TestFrameworkIP+&quot;|&quot;+TestFrameworkName+&quot;|&quot;+TestFrameworkSVNPath+&quot;|&quot;+TestExecutionDateTime+&quot;|&quot;+ProductInterface+&quot;|&quot;+TestCaseID+&quot;|&quot;+Module+&quot;|&quot;+Description+&quot;|&quot;+CsvRequest+&quot;|&quot;+jsonString+&quot;|&quot;+DumpData+&quot;|&quot;+CsvSMS1+&quot;|&quot;+CsvSMS2+&quot;|&quot;+statusCode+&quot;|&quot;+ErrorCode;

log.info(PrintData);
String resultcsvpath = vars.get(&quot;ResultCsvPath&quot;);
f = new FileOutputStream(resultcsvpath,  true);
p = new PrintStream(f); 
this.interpreter.setOut(p); 
print(PrintData);
f.close();</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="View Schedule Topup Positive" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">0</stringProp>
        <longProp name="ThreadGroup.start_time">1481619822000</longProp>
        <longProp name="ThreadGroup.end_time">1481619822000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
          <collectionProp name="Arguments.arguments">
            <elementProp name="CsvSMS1" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS1</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="CsvSMS2" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS2</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="ErrorCode" elementType="Argument">
              <stringProp name="Argument.name">ErrorCode</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="Analysis" elementType="Argument">
              <stringProp name="Argument.name">Analysis</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
          </collectionProp>
        </Arguments>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="View Using msisdn" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;loginId&quot;:&quot;${loginId}&quot;,&quot;password&quot;:&quot;${password}&quot;,&quot;type&quot;:&quot;${ViewScheduleType}&quot;,&quot;data&quot;:{&quot;geoDomainCode&quot;:&quot;${geoDomainCode}&quot;,&quot;domainCode&quot;:&quot;${domainCode}&quot;,&quot;categoryCode&quot;:&quot;${categoryCode}&quot;,&quot;loginId&quot;:&quot;${loginId}&quot;,&quot;msisdn&quot;:&quot;${__property(MOBILENUMBER)}&quot;}}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${host}</stringProp>
          <stringProp name="HTTPSampler.port">${port}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol">${protocol}</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${path}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <XPathExtractor guiclass="XPathExtractorGui" testclass="XPathExtractor" testname="TXNSTATUS" enabled="false">
            <stringProp name="XPathExtractor.default">NOVAL</stringProp>
            <stringProp name="XPathExtractor.refname">MSISDN</stringProp>
            <stringProp name="XPathExtractor.xpathQuery">//*[local-name()=&apos;TXNSTATUS&apos;]/text()</stringProp>
            <boolProp name="XPathExtractor.validate">false</boolProp>
            <boolProp name="XPathExtractor.tolerant">false</boolProp>
            <boolProp name="XPathExtractor.namespace">false</boolProp>
          </XPathExtractor>
          <hashTree/>
          <DebugPostProcessor guiclass="TestBeanGUI" testclass="DebugPostProcessor" testname="Debug PostProcessor" enabled="true">
            <boolProp name="displayJMeterProperties">false</boolProp>
            <boolProp name="displayJMeterVariables">true</boolProp>
            <boolProp name="displaySamplerProperties">true</boolProp>
            <boolProp name="displaySystemProperties">false</boolProp>
          </DebugPostProcessor>
          <hashTree/>
        </hashTree>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Result Writer" enabled="false">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.util.List;
import java.util.ArrayList;

import com.univocity.parsers.common.processor.RowListProcessor;
import com.univocity.parsers.csv.CsvParser;
import com.univocity.parsers.csv.CsvParserSettings;
import com.univocity.parsers.csv.CsvWriter;
import com.univocity.parsers.csv.CsvWriterSettings;

JSONObject jsonObject = new JSONObject();
JSONParser jsonParser = new JSONParser();

String jsonString = prev.getResponseDataAsString();

jsonObject = (JSONObject) jsonParser.parse(jsonString);

vars.put(&quot;statusCode&quot;, jsonObject.get(&quot;statusCode&quot;).toString());
vars.put(&quot;status&quot;, jsonObject.get(&quot;status&quot;).toString());


if(vars.get(&quot;statusCode&quot;).equalsIgnoreCase(&quot;200&quot;) &amp;&amp; vars.get(&quot;status&quot;).equalsIgnoreCase(&quot;true&quot;)){
	log.info(&quot;File Path is &gt;&gt;&gt; &quot; + jsonObject.get(&quot;dataObject&quot;).toString());
	vars.put(&quot;downloadedTemplatePath&quot;, jsonObject.get(&quot;dataObject&quot;).toString());
}else{
	log.info(jsonObject.get(&quot;formError&quot;).toString());
}

FileReader fileReader = new FileReader(vars.get(&quot;downloadedTemplatePath&quot;).toString());
CsvParserSettings parserSettings = new CsvParserSettings();
parserSettings.setLineSeparatorDetectionEnabled(true);

RowListProcessor processor = new RowListProcessor();
parserSettings.setProcessor(processor);
parserSettings.setHeaderExtractionEnabled(true);
parserSettings.setSkipEmptyLines(false);
CsvParser parser = new CsvParser(parserSettings);
parser.parse(fileReader);
List rows = new ArrayList();
rows = processor.getRows();

log.info(&quot;Total no of rows is &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot; + rows.size().toString());

File outputFile = new File(vars.get(&quot;downloadedTemplatePath&quot;).toString());

List finalData = new ArrayList();

for (int k = 0; k&lt; rows.size(); k++) {
	String[] row = (String[])rows.get(k);
	int length = row.length+1;
	String[] data = new String[length];
	int min = Integer.parseInt(row[3]);
	int max = Integer.parseInt(row[4]);
	for (int i = 0; i &lt; row.length; i++) {
		data[i] = row[i];
	}
				
	int amount = min + (int)(Math.random() * ((max - min) + 1));
	data[row.length] = Integer.toString(amount);
	finalData.add(data);
}


String[] header = new String[]{&quot;Mobile number*&quot;,&quot;Subscriber ID*&quot;,&quot;Subscriber name*&quot;,&quot;Minimum transaction amount*&quot;,&quot;Maximum transaction amount*&quot;,&quot;Monthly limit*&quot;,&quot;Used limit*&quot;,&quot;Sub-service *&quot;,&quot;Requested amount*&quot;};
		
Writer writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outputFile)));
CsvWriterSettings settings = new CsvWriterSettings();
CsvWriter csvWriter = new CsvWriter(writer, settings);
StringBuilder row = new StringBuilder();
for (String column : header) {
	if (row.length() &gt; 0) {
		row.append(&quot;,&quot;);
	}
	row.append(column);
}
csvWriter.writeRow(row.toString());

for (String[] object : finalData) {
	StringBuilder row2 = new StringBuilder();
	for (String column : object) {
		if (row2.length() &gt; 0) {
			row2.append(&quot;,&quot;);
		}
		row2.append(column);
	}
	csvWriter.writeRow(row2.toString());
}

csvWriter.close();
String inputFileString = vars.get(&quot;downloadedTemplatePath&quot;).toString().replace(&quot;\\&quot;, &quot;/&quot;);
vars.put(&quot;inputFile&quot;, inputFileString);
vars.put(&quot;noOfRecords&quot;, rows.size().toString());</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
        <CSVDataSet guiclass="TestBeanGUI" testclass="CSVDataSet" testname="CSV Data set config" enabled="true">
          <stringProp name="filename">${CSV path}/VIEW_SCHEDULE_RECHARGE_SINGLE_POSITIVE.csv</stringProp>
          <stringProp name="fileEncoding"></stringProp>
          <stringProp name="variableNames"></stringProp>
          <stringProp name="delimiter">,</stringProp>
          <boolProp name="quotedData">false</boolProp>
          <boolProp name="recycle">true</boolProp>
          <boolProp name="stopThread">false</boolProp>
          <stringProp name="shareMode">shareMode.all</stringProp>
        </CSVDataSet>
        <hashTree/>
        <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Request Reader" enabled="true">
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="script">var sampler = ctx.getCurrentSampler();
var Arguments = sampler.getArguments();
vars.put(&quot;CsvRequest&quot;,&quot;Request&quot;+Arguments);</stringProp>
        </BeanShellPreProcessor>
        <hashTree/>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Result Writer" enabled="true">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.JSONArray;
import java.util.Set;
import org.apache.jmeter.util.JMeterUtils;


String jsonString = prev.getResponseDataAsString();

JSONObject jsonObject = new JSONObject();
JSONParser jsonParser = new JSONParser();

jsonObject = (JSONObject) jsonParser.parse(jsonString);
String statusCodeReq = jsonObject.get(&quot;statusCode&quot;).toString();
String status = jsonObject.get(&quot;status&quot;).toString();
//JSONObject dataObject =  jsonObject.get(&quot;dataObject&quot;);


//Set msisdn=dataObject.keySet();
//log.info(msisdn.toArray()[0]);
//vars.put(&quot;MSIS&quot;,msisdn.toArray()[0].toString());

String statusCode = &quot;&quot;;
if(statusCodeReq.equalsIgnoreCase(&quot;400&quot;) &amp;&amp; status.equalsIgnoreCase(&quot;false&quot;)){
	statusCode = &quot;Fail&quot;;
}else{
	statusCode = &quot;Pass&quot;;
}

String TestCaseID = vars.get(&quot;TestcaseId&quot;);//argument name must be same as defined in csv file
String Module = vars.get(&quot;Module&quot;);//argument name must be same as defined in csv file
String Description = vars.get(&quot;Description&quot;);//argument name must be same as defined in csv file
String CsvRequest = vars.get(&quot;CsvRequest&quot;);
String SVNRepositoryID = vars.get(&quot;SVNRepositoryID&quot;);
String LeadName = vars.get(&quot;LeadName&quot;);
String TestFrameworkIP = vars.get(&quot;TestFrameworkIP&quot;);
String TestFrameworkName = vars.get(&quot;TestFrameworkName&quot;);
String TestFrameworkSVNPath = vars.get(&quot;TestFrameworkSVNPath&quot;);
String TestExecutionDateTime = vars.get(&quot;TestExecutionDateTime&quot;);
String ProductInterface = vars.get(&quot;ProductInterface&quot;);
String CsvSMS1 = vars.get(&quot;CsvSMS1&quot;);
String CsvSMS2 = vars.get(&quot;CsvSMS2&quot;);
String ErrorCode= vars.get(&quot;ErrorCode&quot;);
String Analysis= vars.get(&quot;Analysis&quot;);
String DumpData= vars.get(&quot;DumpData&quot;);

log.info(SVNRepositoryID);
log.info(LeadName);
log.info(ProductInterface);
PrintData=&quot;&quot;+SVNRepositoryID+&quot;|&quot;+LeadName+&quot;|&quot;+TestFrameworkIP+&quot;|&quot;+TestFrameworkName+&quot;|&quot;+TestFrameworkSVNPath+&quot;|&quot;+TestExecutionDateTime+&quot;|&quot;+ProductInterface+&quot;|&quot;+TestCaseID+&quot;|&quot;+Module+&quot;|&quot;+Description+&quot;|&quot;+CsvRequest+&quot;|&quot;+jsonString+&quot;|&quot;+DumpData+&quot;|&quot;+CsvSMS1+&quot;|&quot;+CsvSMS2+&quot;|&quot;+statusCode+&quot;|&quot;+ErrorCode;


log.info(PrintData);
String resultcsvpath = vars.get(&quot;ResultCsvPath&quot;);
f = new FileOutputStream(resultcsvpath,  true);
p = new PrintStream(f); 
this.interpreter.setOut(p); 
print(PrintData);
f.close();
//MeterUtils.setProperty(&quot;MSISDN&quot;,vars.get(&quot;MSIS&quot;));
</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="View Schedule Topup Negative" enabled="false">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">22</stringProp>
        <stringProp name="ThreadGroup.ramp_time">44</stringProp>
        <longProp name="ThreadGroup.start_time">1481619822000</longProp>
        <longProp name="ThreadGroup.end_time">1481619822000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
          <collectionProp name="Arguments.arguments">
            <elementProp name="CsvSMS1" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS1</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="CsvSMS2" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS2</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="ErrorCode" elementType="Argument">
              <stringProp name="Argument.name">ErrorCode</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="Analysis" elementType="Argument">
              <stringProp name="Argument.name">Analysis</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
          </collectionProp>
        </Arguments>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="View Using msisdn " enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;loginId&quot;:&quot;${loginId}&quot;,&quot;password&quot;:&quot;${password}&quot;,&quot;type&quot;:&quot;${ViewScheduleType}&quot;,&quot;data&quot;:{&quot;geoDomainCode&quot;:&quot;${geoDomainCode}&quot;,&quot;domainCode&quot;:&quot;${domainCode}&quot;,&quot;categoryCode&quot;:&quot;${categoryCode}&quot;,&quot;loginId&quot;:&quot;${dataloginId}&quot;,&quot;msisdn&quot;:&quot;${msisdn}&quot;}}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${host}</stringProp>
          <stringProp name="HTTPSampler.port">${port}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol">${protocol}</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${path}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <XPathExtractor guiclass="XPathExtractorGui" testclass="XPathExtractor" testname="TXNSTATUS" enabled="false">
            <stringProp name="XPathExtractor.default">NOVAL</stringProp>
            <stringProp name="XPathExtractor.refname">MSISDN</stringProp>
            <stringProp name="XPathExtractor.xpathQuery">//*[local-name()=&apos;TXNSTATUS&apos;]/text()</stringProp>
            <boolProp name="XPathExtractor.validate">false</boolProp>
            <boolProp name="XPathExtractor.tolerant">false</boolProp>
            <boolProp name="XPathExtractor.namespace">false</boolProp>
          </XPathExtractor>
          <hashTree/>
          <DebugPostProcessor guiclass="TestBeanGUI" testclass="DebugPostProcessor" testname="Debug PostProcessor" enabled="true">
            <boolProp name="displayJMeterProperties">false</boolProp>
            <boolProp name="displayJMeterVariables">true</boolProp>
            <boolProp name="displaySamplerProperties">true</boolProp>
            <boolProp name="displaySystemProperties">false</boolProp>
          </DebugPostProcessor>
          <hashTree/>
        </hashTree>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Result Writer" enabled="false">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.util.List;
import java.util.ArrayList;

import com.univocity.parsers.common.processor.RowListProcessor;
import com.univocity.parsers.csv.CsvParser;
import com.univocity.parsers.csv.CsvParserSettings;
import com.univocity.parsers.csv.CsvWriter;
import com.univocity.parsers.csv.CsvWriterSettings;

JSONObject jsonObject = new JSONObject();
JSONParser jsonParser = new JSONParser();

String jsonString = prev.getResponseDataAsString();

jsonObject = (JSONObject) jsonParser.parse(jsonString);

vars.put(&quot;statusCode&quot;, jsonObject.get(&quot;statusCode&quot;).toString());
vars.put(&quot;status&quot;, jsonObject.get(&quot;status&quot;).toString());


if(vars.get(&quot;statusCode&quot;).equalsIgnoreCase(&quot;200&quot;) &amp;&amp; vars.get(&quot;status&quot;).equalsIgnoreCase(&quot;true&quot;)){
	log.info(&quot;File Path is &gt;&gt;&gt; &quot; + jsonObject.get(&quot;dataObject&quot;).toString());
	vars.put(&quot;downloadedTemplatePath&quot;, jsonObject.get(&quot;dataObject&quot;).toString());
}else{
	log.info(jsonObject.get(&quot;formError&quot;).toString());
}

FileReader fileReader = new FileReader(vars.get(&quot;downloadedTemplatePath&quot;).toString());
CsvParserSettings parserSettings = new CsvParserSettings();
parserSettings.setLineSeparatorDetectionEnabled(true);

RowListProcessor processor = new RowListProcessor();
parserSettings.setProcessor(processor);
parserSettings.setHeaderExtractionEnabled(true);
parserSettings.setSkipEmptyLines(false);
CsvParser parser = new CsvParser(parserSettings);
parser.parse(fileReader);
List rows = new ArrayList();
rows = processor.getRows();

log.info(&quot;Total no of rows is &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot; + rows.size().toString());

File outputFile = new File(vars.get(&quot;downloadedTemplatePath&quot;).toString());

List finalData = new ArrayList();

for (int k = 0; k&lt; rows.size(); k++) {
	String[] row = (String[])rows.get(k);
	int length = row.length+1;
	String[] data = new String[length];
	int min = Integer.parseInt(row[3]);
	int max = Integer.parseInt(row[4]);
	for (int i = 0; i &lt; row.length; i++) {
		data[i] = row[i];
	}
				
	int amount = min + (int)(Math.random() * ((max - min) + 1));
	data[row.length] = Integer.toString(amount);
	finalData.add(data);
}


String[] header = new String[]{&quot;Mobile number*&quot;,&quot;Subscriber ID*&quot;,&quot;Subscriber name*&quot;,&quot;Minimum transaction amount*&quot;,&quot;Maximum transaction amount*&quot;,&quot;Monthly limit*&quot;,&quot;Used limit*&quot;,&quot;Sub-service *&quot;,&quot;Requested amount*&quot;};
		
Writer writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outputFile)));
CsvWriterSettings settings = new CsvWriterSettings();
CsvWriter csvWriter = new CsvWriter(writer, settings);
StringBuilder row = new StringBuilder();
for (String column : header) {
	if (row.length() &gt; 0) {
		row.append(&quot;,&quot;);
	}
	row.append(column);
}
csvWriter.writeRow(row.toString());

for (String[] object : finalData) {
	StringBuilder row2 = new StringBuilder();
	for (String column : object) {
		if (row2.length() &gt; 0) {
			row2.append(&quot;,&quot;);
		}
		row2.append(column);
	}
	csvWriter.writeRow(row2.toString());
}

csvWriter.close();
String inputFileString = vars.get(&quot;downloadedTemplatePath&quot;).toString().replace(&quot;\\&quot;, &quot;/&quot;);
vars.put(&quot;inputFile&quot;, inputFileString);
vars.put(&quot;noOfRecords&quot;, rows.size().toString());</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
        <CSVDataSet guiclass="TestBeanGUI" testclass="CSVDataSet" testname="CSV Data set config" enabled="true">
          <stringProp name="filename">${CSV path}/VIEW_SCHEDULE_RECHARGE_SINGLE_NEGATIVE.csv</stringProp>
          <stringProp name="fileEncoding"></stringProp>
          <stringProp name="variableNames"></stringProp>
          <stringProp name="delimiter">,</stringProp>
          <boolProp name="quotedData">false</boolProp>
          <boolProp name="recycle">true</boolProp>
          <boolProp name="stopThread">false</boolProp>
          <stringProp name="shareMode">shareMode.all</stringProp>
        </CSVDataSet>
        <hashTree/>
        <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Request Reader" enabled="true">
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="script">var sampler = ctx.getCurrentSampler();
var Arguments = sampler.getArguments();
vars.put(&quot;CsvRequest&quot;,&quot;Request&quot;+Arguments);</stringProp>
        </BeanShellPreProcessor>
        <hashTree/>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Result Writer" enabled="true">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;



String jsonString = prev.getResponseDataAsString();

JSONObject jsonObject = new JSONObject();
JSONParser jsonParser = new JSONParser();

jsonObject = (JSONObject) jsonParser.parse(jsonString);
String statusCodeReq = jsonObject.get(&quot;statusCode&quot;).toString();
String status = jsonObject.get(&quot;status&quot;).toString();
String statusCode = &quot;&quot;;
if(statusCodeReq.equalsIgnoreCase(&quot;400&quot;) &amp;&amp; status.equalsIgnoreCase(&quot;false&quot;)){
	statusCode = &quot;Pass&quot;;
}else{
	statusCode = &quot;Fail&quot;;
}

String TestCaseID = vars.get(&quot;TestcaseId&quot;);//argument name must be same as defined in csv file
String Module = vars.get(&quot;Module&quot;);//argument name must be same as defined in csv file
String Description = vars.get(&quot;Description&quot;);//argument name must be same as defined in csv file
String CsvRequest = vars.get(&quot;CsvRequest&quot;);
String SVNRepositoryID = vars.get(&quot;SVNRepositoryID&quot;);
String LeadName = vars.get(&quot;LeadName&quot;);
String TestFrameworkIP = vars.get(&quot;TestFrameworkIP&quot;);
String TestFrameworkName = vars.get(&quot;TestFrameworkName&quot;);
String TestFrameworkSVNPath = vars.get(&quot;TestFrameworkSVNPath&quot;);
String TestExecutionDateTime = vars.get(&quot;TestExecutionDateTime&quot;);
String ProductInterface = vars.get(&quot;ProductInterface&quot;);
String CsvSMS1 = vars.get(&quot;CsvSMS1&quot;);
String CsvSMS2 = vars.get(&quot;CsvSMS2&quot;);
String ErrorCode= vars.get(&quot;ErrorCode&quot;);
String Analysis= vars.get(&quot;Analysis&quot;);
String DumpData= vars.get(&quot;DumpData&quot;);

log.info(SVNRepositoryID);
log.info(LeadName);
log.info(ProductInterface);
PrintData=&quot;&quot;+SVNRepositoryID+&quot;|&quot;+LeadName+&quot;|&quot;+TestFrameworkIP+&quot;|&quot;+TestFrameworkName+&quot;|&quot;+TestFrameworkSVNPath+&quot;|&quot;+TestExecutionDateTime+&quot;|&quot;+ProductInterface+&quot;|&quot;+TestCaseID+&quot;|&quot;+Module+&quot;|&quot;+Description+&quot;|&quot;+CsvRequest+&quot;|&quot;+jsonString+&quot;|&quot;+DumpData+&quot;|&quot;+CsvSMS1+&quot;|&quot;+CsvSMS2+&quot;|&quot;+statusCode+&quot;|&quot;+ErrorCode;


log.info(PrintData);
String resultcsvpath = vars.get(&quot;ResultCsvPath&quot;);
f = new FileOutputStream(resultcsvpath,  true);
p = new PrintStream(f); 
this.interpreter.setOut(p); 
print(PrintData);
f.close();</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Cancel Schedule Recharge Batch Detail Positive Scenario" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">0</stringProp>
        <longProp name="ThreadGroup.start_time">1481619822000</longProp>
        <longProp name="ThreadGroup.end_time">1481619822000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
          <collectionProp name="Arguments.arguments">
            <elementProp name="CsvSMS1" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS1</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="CsvSMS2" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS2</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="ErrorCode" elementType="Argument">
              <stringProp name="Argument.name">ErrorCode</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="Analysis" elementType="Argument">
              <stringProp name="Argument.name">Analysis</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
          </collectionProp>
        </Arguments>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Cancel Using batchID http request" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;loginId&quot;:&quot;${loginId}&quot;,&quot;password&quot;:&quot;${password}&quot;,&quot;type&quot;:&quot;${cancelBatchDetailType}&quot;,&quot;data&quot;:{&quot;loginId&quot;:&quot;${userLoginID}&quot;,&quot;batchID&quot;:&quot;${__property(BATCHID)}&quot;}}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${host}</stringProp>
          <stringProp name="HTTPSampler.port">${port}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol">${protocol}</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${path}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree/>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Result Writer" enabled="false">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.util.List;
import java.util.ArrayList;

import com.univocity.parsers.common.processor.RowListProcessor;
import com.univocity.parsers.csv.CsvParser;
import com.univocity.parsers.csv.CsvParserSettings;
import com.univocity.parsers.csv.CsvWriter;
import com.univocity.parsers.csv.CsvWriterSettings;

JSONObject jsonObject = new JSONObject();
JSONParser jsonParser = new JSONParser();

String jsonString = prev.getResponseDataAsString();

jsonObject = (JSONObject) jsonParser.parse(jsonString);

vars.put(&quot;statusCode&quot;, jsonObject.get(&quot;statusCode&quot;).toString());
vars.put(&quot;status&quot;, jsonObject.get(&quot;status&quot;).toString());


if(vars.get(&quot;statusCode&quot;).equalsIgnoreCase(&quot;200&quot;) &amp;&amp; vars.get(&quot;status&quot;).equalsIgnoreCase(&quot;true&quot;)){
	log.info(&quot;File Path is &gt;&gt;&gt; &quot; + jsonObject.get(&quot;dataObject&quot;).toString());
	vars.put(&quot;downloadedTemplatePath&quot;, jsonObject.get(&quot;dataObject&quot;).toString());
}else{
	log.info(jsonObject.get(&quot;formError&quot;).toString());
}

FileReader fileReader = new FileReader(vars.get(&quot;downloadedTemplatePath&quot;).toString());
CsvParserSettings parserSettings = new CsvParserSettings();
parserSettings.setLineSeparatorDetectionEnabled(true);

RowListProcessor processor = new RowListProcessor();
parserSettings.setProcessor(processor);
parserSettings.setHeaderExtractionEnabled(true);
parserSettings.setSkipEmptyLines(false);
CsvParser parser = new CsvParser(parserSettings);
parser.parse(fileReader);
List rows = new ArrayList();
rows = processor.getRows();

log.info(&quot;Total no of rows is &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot; + rows.size().toString());

File outputFile = new File(vars.get(&quot;downloadedTemplatePath&quot;).toString());

List finalData = new ArrayList();

for (int k = 0; k&lt; rows.size(); k++) {
	String[] row = (String[])rows.get(k);
	int length = row.length+1;
	String[] data = new String[length];
	int min = Integer.parseInt(row[3]);
	int max = Integer.parseInt(row[4]);
	for (int i = 0; i &lt; row.length; i++) {
		data[i] = row[i];
	}
				
	int amount = min + (int)(Math.random() * ((max - min) + 1));
	data[row.length] = Integer.toString(amount);
	finalData.add(data);
}


String[] header = new String[]{&quot;Mobile number*&quot;,&quot;Subscriber ID*&quot;,&quot;Subscriber name*&quot;,&quot;Minimum transaction amount*&quot;,&quot;Maximum transaction amount*&quot;,&quot;Monthly limit*&quot;,&quot;Used limit*&quot;,&quot;Sub-service *&quot;,&quot;Requested amount*&quot;};
		
Writer writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outputFile)));
CsvWriterSettings settings = new CsvWriterSettings();
CsvWriter csvWriter = new CsvWriter(writer, settings);
StringBuilder row = new StringBuilder();
for (String column : header) {
	if (row.length() &gt; 0) {
		row.append(&quot;,&quot;);
	}
	row.append(column);
}
csvWriter.writeRow(row.toString());

for (String[] object : finalData) {
	StringBuilder row2 = new StringBuilder();
	for (String column : object) {
		if (row2.length() &gt; 0) {
			row2.append(&quot;,&quot;);
		}
		row2.append(column);
	}
	csvWriter.writeRow(row2.toString());
}

csvWriter.close();
String inputFileString = vars.get(&quot;downloadedTemplatePath&quot;).toString().replace(&quot;\\&quot;, &quot;/&quot;);
vars.put(&quot;inputFile&quot;, inputFileString);
vars.put(&quot;noOfRecords&quot;, rows.size().toString());</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
        <CSVDataSet guiclass="TestBeanGUI" testclass="CSVDataSet" testname="CSV Data set config" enabled="true">
          <stringProp name="filename">${CSV path}/CANCEL_SCHEDULE_VIEW_BATCHDETAIL_POSITIVE.csv</stringProp>
          <stringProp name="fileEncoding"></stringProp>
          <stringProp name="variableNames"></stringProp>
          <stringProp name="delimiter">,</stringProp>
          <boolProp name="quotedData">false</boolProp>
          <boolProp name="recycle">true</boolProp>
          <boolProp name="stopThread">false</boolProp>
          <stringProp name="shareMode">shareMode.all</stringProp>
        </CSVDataSet>
        <hashTree/>
        <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Request Reader" enabled="true">
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="script">//-- SKD
// -- updating the variables
var sampler = ctx.getCurrentSampler();
var Arguments = sampler.getArguments();
vars.put(&quot;CsvRequest&quot;,&quot;Request&quot;+Arguments);</stringProp>
        </BeanShellPreProcessor>
        <hashTree/>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Result Writer" enabled="true">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.JSONArray;


String jsonString = prev.getResponseDataAsString();

JSONObject jsonObject = new JSONObject();
JSONParser jsonParser = new JSONParser();

jsonObject = (JSONObject) jsonParser.parse(jsonString);

String statusCodeReq = jsonObject.get(&quot;statusCode&quot;).toString();
String status = jsonObject.get(&quot;status&quot;).toString();
JSONObject dataObject = jsonObject.get(&quot;dataObject&quot;);

String msisdnDetails = dataObject.get(&quot;scheduleDetailList&quot;).toString();
String batchDetails = dataObject.get(&quot;scheduleBatchMasterVO&quot;).toString();


String statusCode = &quot;&quot;;
if(statusCodeReq.equalsIgnoreCase(&quot;400&quot;) &amp;&amp; status.equalsIgnoreCase(&quot;false&quot;)){
	statusCode = &quot;Fail&quot;;
}else{
	statusCode = &quot;Pass&quot;;
}


String TestCaseID = vars.get(&quot;TestcaseId&quot;);//argument name must be same as defined in csv file
String Module = vars.get(&quot;Module&quot;);//argument name must be same as defined in csv file
String Description = vars.get(&quot;Description&quot;);//argument name must be same as defined in csv file
String CsvRequest = vars.get(&quot;CsvRequest&quot;);
String SVNRepositoryID = vars.get(&quot;SVNRepositoryID&quot;);
String LeadName = vars.get(&quot;LeadName&quot;);
String TestFrameworkIP = vars.get(&quot;TestFrameworkIP&quot;);
String TestFrameworkName = vars.get(&quot;TestFrameworkName&quot;);
String TestFrameworkSVNPath = vars.get(&quot;TestFrameworkSVNPath&quot;);
String TestExecutionDateTime = vars.get(&quot;TestExecutionDateTime&quot;);
String ProductInterface = vars.get(&quot;ProductInterface&quot;);
String CsvSMS1 = vars.get(&quot;CsvSMS1&quot;);
String CsvSMS2 = vars.get(&quot;CsvSMS2&quot;);
String ErrorCode= vars.get(&quot;ErrorCode&quot;);
String Analysis= vars.get(&quot;Analysis&quot;);
String DumpData= vars.get(&quot;DumpData&quot;);

log.info(SVNRepositoryID);
log.info(LeadName);
log.info(ProductInterface);
PrintData=&quot;&quot;+SVNRepositoryID+&quot;|&quot;+LeadName+&quot;|&quot;+TestFrameworkIP+&quot;|&quot;+TestFrameworkName+&quot;|&quot;+TestFrameworkSVNPath+&quot;|&quot;+TestExecutionDateTime+&quot;|&quot;+ProductInterface+&quot;|&quot;+TestCaseID+&quot;|&quot;+Module+&quot;|&quot;+Description+&quot;|&quot;+CsvRequest+&quot;|&quot;+jsonString+&quot;|&quot;+DumpData+&quot;|&quot;+CsvSMS1+&quot;|&quot;+CsvSMS2+&quot;|&quot;+statusCode+&quot;|&quot;+ErrorCode;


log.info(PrintData);
String resultcsvpath = vars.get(&quot;ResultCsvPath&quot;);
f = new FileOutputStream(resultcsvpath,  true);
p = new PrintStream(f); 
this.interpreter.setOut(p); 
print(PrintData);
f.close();
</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Cancel Schedule Recharge Batch Detail Negative Scenario" enabled="false">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">0</stringProp>
        <longProp name="ThreadGroup.start_time">1481619822000</longProp>
        <longProp name="ThreadGroup.end_time">1481619822000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
          <collectionProp name="Arguments.arguments">
            <elementProp name="CsvSMS1" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS1</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="CsvSMS2" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS2</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="ErrorCode" elementType="Argument">
              <stringProp name="Argument.name">ErrorCode</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="Analysis" elementType="Argument">
              <stringProp name="Argument.name">Analysis</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
          </collectionProp>
        </Arguments>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Cancel Using batchID http request" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;loginId&quot;:&quot;${loginId}&quot;,&quot;password&quot;:&quot;${password}&quot;,&quot;type&quot;:&quot;${cancelBatchDetailType}&quot;,&quot;data&quot;:{&quot;loginId&quot;:&quot;${userLoginID}&quot;,&quot;batchID&quot;:&quot;${BATCHID}&quot;}}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${host}</stringProp>
          <stringProp name="HTTPSampler.port">${port}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol">${protocol}</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${path}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree/>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Result Writer" enabled="false">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.util.List;
import java.util.ArrayList;

import com.univocity.parsers.common.processor.RowListProcessor;
import com.univocity.parsers.csv.CsvParser;
import com.univocity.parsers.csv.CsvParserSettings;
import com.univocity.parsers.csv.CsvWriter;
import com.univocity.parsers.csv.CsvWriterSettings;

JSONObject jsonObject = new JSONObject();
JSONParser jsonParser = new JSONParser();

String jsonString = prev.getResponseDataAsString();

jsonObject = (JSONObject) jsonParser.parse(jsonString);

vars.put(&quot;statusCode&quot;, jsonObject.get(&quot;statusCode&quot;).toString());
vars.put(&quot;status&quot;, jsonObject.get(&quot;status&quot;).toString());


if(vars.get(&quot;statusCode&quot;).equalsIgnoreCase(&quot;200&quot;) &amp;&amp; vars.get(&quot;status&quot;).equalsIgnoreCase(&quot;true&quot;)){
	log.info(&quot;File Path is &gt;&gt;&gt; &quot; + jsonObject.get(&quot;dataObject&quot;).toString());
	vars.put(&quot;downloadedTemplatePath&quot;, jsonObject.get(&quot;dataObject&quot;).toString());
}else{
	log.info(jsonObject.get(&quot;formError&quot;).toString());
}

FileReader fileReader = new FileReader(vars.get(&quot;downloadedTemplatePath&quot;).toString());
CsvParserSettings parserSettings = new CsvParserSettings();
parserSettings.setLineSeparatorDetectionEnabled(true);

RowListProcessor processor = new RowListProcessor();
parserSettings.setProcessor(processor);
parserSettings.setHeaderExtractionEnabled(true);
parserSettings.setSkipEmptyLines(false);
CsvParser parser = new CsvParser(parserSettings);
parser.parse(fileReader);
List rows = new ArrayList();
rows = processor.getRows();

log.info(&quot;Total no of rows is &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot; + rows.size().toString());

File outputFile = new File(vars.get(&quot;downloadedTemplatePath&quot;).toString());

List finalData = new ArrayList();

for (int k = 0; k&lt; rows.size(); k++) {
	String[] row = (String[])rows.get(k);
	int length = row.length+1;
	String[] data = new String[length];
	int min = Integer.parseInt(row[3]);
	int max = Integer.parseInt(row[4]);
	for (int i = 0; i &lt; row.length; i++) {
		data[i] = row[i];
	}
				
	int amount = min + (int)(Math.random() * ((max - min) + 1));
	data[row.length] = Integer.toString(amount);
	finalData.add(data);
}


String[] header = new String[]{&quot;Mobile number*&quot;,&quot;Subscriber ID*&quot;,&quot;Subscriber name*&quot;,&quot;Minimum transaction amount*&quot;,&quot;Maximum transaction amount*&quot;,&quot;Monthly limit*&quot;,&quot;Used limit*&quot;,&quot;Sub-service *&quot;,&quot;Requested amount*&quot;};
		
Writer writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outputFile)));
CsvWriterSettings settings = new CsvWriterSettings();
CsvWriter csvWriter = new CsvWriter(writer, settings);
StringBuilder row = new StringBuilder();
for (String column : header) {
	if (row.length() &gt; 0) {
		row.append(&quot;,&quot;);
	}
	row.append(column);
}
csvWriter.writeRow(row.toString());

for (String[] object : finalData) {
	StringBuilder row2 = new StringBuilder();
	for (String column : object) {
		if (row2.length() &gt; 0) {
			row2.append(&quot;,&quot;);
		}
		row2.append(column);
	}
	csvWriter.writeRow(row2.toString());
}

csvWriter.close();
String inputFileString = vars.get(&quot;downloadedTemplatePath&quot;).toString().replace(&quot;\\&quot;, &quot;/&quot;);
vars.put(&quot;inputFile&quot;, inputFileString);
vars.put(&quot;noOfRecords&quot;, rows.size().toString());</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
        <CSVDataSet guiclass="TestBeanGUI" testclass="CSVDataSet" testname="CSV Data set config" enabled="true">
          <stringProp name="filename">${CSV path}/CANCEL_SCHEDULE_VIEW_BATCHDETAIL_NEGATIVE.csv</stringProp>
          <stringProp name="fileEncoding"></stringProp>
          <stringProp name="variableNames"></stringProp>
          <stringProp name="delimiter">,</stringProp>
          <boolProp name="quotedData">false</boolProp>
          <boolProp name="recycle">true</boolProp>
          <boolProp name="stopThread">false</boolProp>
          <stringProp name="shareMode">shareMode.all</stringProp>
        </CSVDataSet>
        <hashTree/>
        <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Request Reader" enabled="true">
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="script">//-- SKD
// -- updating the variables
var sampler = ctx.getCurrentSampler();
var Arguments = sampler.getArguments();
vars.put(&quot;CsvRequest&quot;,&quot;Request&quot;+Arguments);</stringProp>
        </BeanShellPreProcessor>
        <hashTree/>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Result Writer" enabled="true">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.JSONArray;


String jsonString = prev.getResponseDataAsString();

JSONObject jsonObject = new JSONObject();
JSONParser jsonParser = new JSONParser();

jsonObject = (JSONObject) jsonParser.parse(jsonString);
String statusCodeReq = jsonObject.get(&quot;statusCode&quot;).toString();
String status = jsonObject.get(&quot;status&quot;).toString();
JSONObject dataObject = (JSONArray) jsonObject.get(&quot;dataObject&quot;);


String statusCode = &quot;&quot;;
if(statusCodeReq.equalsIgnoreCase(&quot;400&quot;) &amp;&amp; status.equalsIgnoreCase(&quot;false&quot;)){
	statusCode = &quot;Pass&quot;;
}else{
	statusCode = &quot;Fail&quot;;
}


String TestCaseID = vars.get(&quot;TestcaseId&quot;);//argument name must be same as defined in csv file
String Module = vars.get(&quot;Module&quot;);//argument name must be same as defined in csv file
String Description = vars.get(&quot;Description&quot;);//argument name must be same as defined in csv file
String CsvRequest = vars.get(&quot;CsvRequest&quot;);
String SVNRepositoryID = vars.get(&quot;SVNRepositoryID&quot;);
String LeadName = vars.get(&quot;LeadName&quot;);
String TestFrameworkIP = vars.get(&quot;TestFrameworkIP&quot;);
String TestFrameworkName = vars.get(&quot;TestFrameworkName&quot;);
String TestFrameworkSVNPath = vars.get(&quot;TestFrameworkSVNPath&quot;);
String TestExecutionDateTime = vars.get(&quot;TestExecutionDateTime&quot;);
String ProductInterface = vars.get(&quot;ProductInterface&quot;);
String CsvSMS1 = vars.get(&quot;CsvSMS1&quot;);
String CsvSMS2 = vars.get(&quot;CsvSMS2&quot;);
String ErrorCode= vars.get(&quot;ErrorCode&quot;);
String Analysis= vars.get(&quot;Analysis&quot;);
String DumpData= vars.get(&quot;DumpData&quot;);

log.info(SVNRepositoryID);
log.info(LeadName);
log.info(ProductInterface);
PrintData=&quot;&quot;+SVNRepositoryID+&quot;|&quot;+LeadName+&quot;|&quot;+TestFrameworkIP+&quot;|&quot;+TestFrameworkName+&quot;|&quot;+TestFrameworkSVNPath+&quot;|&quot;+TestExecutionDateTime+&quot;|&quot;+ProductInterface+&quot;|&quot;+TestCaseID+&quot;|&quot;+Module+&quot;|&quot;+Description+&quot;|&quot;+CsvRequest+&quot;|&quot;+jsonString+&quot;|&quot;+DumpData+&quot;|&quot;+CsvSMS1+&quot;|&quot;+CsvSMS2+&quot;|&quot;+statusCode+&quot;|&quot;+ErrorCode;


log.info(PrintData);
String resultcsvpath = vars.get(&quot;ResultCsvPath&quot;);
f = new FileOutputStream(resultcsvpath,  true);
p = new PrintStream(f); 
this.interpreter.setOut(p); 
print(PrintData);
f.close();
</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Cancel Schedule Recharge BATCH MSISDN Positve Scenario" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">0</stringProp>
        <longProp name="ThreadGroup.start_time">1481619822000</longProp>
        <longProp name="ThreadGroup.end_time">1481619822000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
          <collectionProp name="Arguments.arguments">
            <elementProp name="CsvSMS1" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS1</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="CsvSMS2" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS2</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="ErrorCode" elementType="Argument">
              <stringProp name="Argument.name">ErrorCode</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="Analysis" elementType="Argument">
              <stringProp name="Argument.name">Analysis</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
          </collectionProp>
        </Arguments>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Cancel Using batchID http request" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;loginId&quot;:&quot;${loginId}&quot;,&quot;password&quot;:&quot;${password}&quot;,&quot;type&quot;:&quot;${viewcancelMSISDNType}&quot;,&quot;data&quot;:{&quot;loginId&quot;:&quot;${userLoginID}&quot;,&quot;batchID&quot;:&quot;${__property(BATCHID)}&quot;,&quot;mobileNumbers&quot;:&quot;${__property(MOBILENUMBER)}&quot;}}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${host}</stringProp>
          <stringProp name="HTTPSampler.port">${port}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol">${protocol}</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${path}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree/>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Result Writer" enabled="false">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.util.List;
import java.util.ArrayList;

import com.univocity.parsers.common.processor.RowListProcessor;
import com.univocity.parsers.csv.CsvParser;
import com.univocity.parsers.csv.CsvParserSettings;
import com.univocity.parsers.csv.CsvWriter;
import com.univocity.parsers.csv.CsvWriterSettings;

JSONObject jsonObject = new JSONObject();
JSONParser jsonParser = new JSONParser();

String jsonString = prev.getResponseDataAsString();

jsonObject = (JSONObject) jsonParser.parse(jsonString);

vars.put(&quot;statusCode&quot;, jsonObject.get(&quot;statusCode&quot;).toString());
vars.put(&quot;status&quot;, jsonObject.get(&quot;status&quot;).toString());


if(vars.get(&quot;statusCode&quot;).equalsIgnoreCase(&quot;200&quot;) &amp;&amp; vars.get(&quot;status&quot;).equalsIgnoreCase(&quot;true&quot;)){
	log.info(&quot;File Path is &gt;&gt;&gt; &quot; + jsonObject.get(&quot;dataObject&quot;).toString());
	vars.put(&quot;downloadedTemplatePath&quot;, jsonObject.get(&quot;dataObject&quot;).toString());
}else{
	log.info(jsonObject.get(&quot;formError&quot;).toString());
}

FileReader fileReader = new FileReader(vars.get(&quot;downloadedTemplatePath&quot;).toString());
CsvParserSettings parserSettings = new CsvParserSettings();
parserSettings.setLineSeparatorDetectionEnabled(true);

RowListProcessor processor = new RowListProcessor();
parserSettings.setProcessor(processor);
parserSettings.setHeaderExtractionEnabled(true);
parserSettings.setSkipEmptyLines(false);
CsvParser parser = new CsvParser(parserSettings);
parser.parse(fileReader);
List rows = new ArrayList();
rows = processor.getRows();

log.info(&quot;Total no of rows is &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot; + rows.size().toString());

File outputFile = new File(vars.get(&quot;downloadedTemplatePath&quot;).toString());

List finalData = new ArrayList();

for (int k = 0; k&lt; rows.size(); k++) {
	String[] row = (String[])rows.get(k);
	int length = row.length+1;
	String[] data = new String[length];
	int min = Integer.parseInt(row[3]);
	int max = Integer.parseInt(row[4]);
	for (int i = 0; i &lt; row.length; i++) {
		data[i] = row[i];
	}
				
	int amount = min + (int)(Math.random() * ((max - min) + 1));
	data[row.length] = Integer.toString(amount);
	finalData.add(data);
}


String[] header = new String[]{&quot;Mobile number*&quot;,&quot;Subscriber ID*&quot;,&quot;Subscriber name*&quot;,&quot;Minimum transaction amount*&quot;,&quot;Maximum transaction amount*&quot;,&quot;Monthly limit*&quot;,&quot;Used limit*&quot;,&quot;Sub-service *&quot;,&quot;Requested amount*&quot;};
		
Writer writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outputFile)));
CsvWriterSettings settings = new CsvWriterSettings();
CsvWriter csvWriter = new CsvWriter(writer, settings);
StringBuilder row = new StringBuilder();
for (String column : header) {
	if (row.length() &gt; 0) {
		row.append(&quot;,&quot;);
	}
	row.append(column);
}
csvWriter.writeRow(row.toString());

for (String[] object : finalData) {
	StringBuilder row2 = new StringBuilder();
	for (String column : object) {
		if (row2.length() &gt; 0) {
			row2.append(&quot;,&quot;);
		}
		row2.append(column);
	}
	csvWriter.writeRow(row2.toString());
}

csvWriter.close();
String inputFileString = vars.get(&quot;downloadedTemplatePath&quot;).toString().replace(&quot;\\&quot;, &quot;/&quot;);
vars.put(&quot;inputFile&quot;, inputFileString);
vars.put(&quot;noOfRecords&quot;, rows.size().toString());</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
        <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Request Reader" enabled="true">
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="script">//-- SKD
// -- updating the variables
var sampler = ctx.getCurrentSampler();
var Arguments = sampler.getArguments();
vars.put(&quot;CsvRequest&quot;,&quot;Request&quot;+Arguments);</stringProp>
        </BeanShellPreProcessor>
        <hashTree/>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Result Writer" enabled="true">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.JSONArray;


String jsonString = prev.getResponseDataAsString();

JSONObject jsonObject = new JSONObject();
JSONParser jsonParser = new JSONParser();

jsonObject = (JSONObject) jsonParser.parse(jsonString);
String statusCodeReq = jsonObject.get(&quot;statusCode&quot;).toString();
String status = jsonObject.get(&quot;status&quot;).toString();
JSONObject dataObject = jsonObject.get(&quot;dataObject&quot;);

String batchAndMsisdnDetails = dataObject.get(&quot;scheduleMasterVOList&quot;).toString();

if(statusCodeReq.equalsIgnoreCase(&quot;400&quot;) &amp;&amp; status.equalsIgnoreCase(&quot;false&quot;)){
	statusCode = &quot;Fail&quot;;
}else{
	statusCode = &quot;Pass&quot;;
}

String TestCaseID = vars.get(&quot;TestcaseId&quot;);//argument name must be same as defined in csv file
String Module = vars.get(&quot;Module&quot;);//argument name must be same as defined in csv file
String Description = vars.get(&quot;Description&quot;);//argument name must be same as defined in csv file
String CsvRequest = vars.get(&quot;CsvRequest&quot;);
String SVNRepositoryID = vars.get(&quot;SVNRepositoryID&quot;);
String LeadName = vars.get(&quot;LeadName&quot;);
String TestFrameworkIP = vars.get(&quot;TestFrameworkIP&quot;);
String TestFrameworkName = vars.get(&quot;TestFrameworkName&quot;);
String TestFrameworkSVNPath = vars.get(&quot;TestFrameworkSVNPath&quot;);
String TestExecutionDateTime = vars.get(&quot;TestExecutionDateTime&quot;);
String ProductInterface = vars.get(&quot;ProductInterface&quot;);
String CsvSMS1 = vars.get(&quot;CsvSMS1&quot;);
String CsvSMS2 = vars.get(&quot;CsvSMS2&quot;);
String ErrorCode= vars.get(&quot;ErrorCode&quot;);
String Analysis= vars.get(&quot;Analysis&quot;);
String DumpData= vars.get(&quot;DumpData&quot;);

log.info(SVNRepositoryID);
log.info(LeadName);
log.info(ProductInterface);
PrintData=&quot;&quot;+SVNRepositoryID+&quot;|&quot;+LeadName+&quot;|&quot;+TestFrameworkIP+&quot;|&quot;+TestFrameworkName+&quot;|&quot;+TestFrameworkSVNPath+&quot;|&quot;+TestExecutionDateTime+&quot;|&quot;+ProductInterface+&quot;|&quot;+TestCaseID+&quot;|&quot;+Module+&quot;|&quot;+Description+&quot;|&quot;+CsvRequest+&quot;|&quot;+jsonString+&quot;|&quot;+DumpData+&quot;|&quot;+CsvSMS1+&quot;|&quot;+CsvSMS2+&quot;|&quot;+statusCode+&quot;|&quot;+ErrorCode;


log.info(PrintData);
String resultcsvpath = vars.get(&quot;ResultCsvPath&quot;);
f = new FileOutputStream(resultcsvpath,  true);
p = new PrintStream(f); 
this.interpreter.setOut(p); 
print(PrintData);
f.close();
</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Cancel Schedule Recharge BATCH MSISDN Negative Scenario" enabled="false">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">2</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">0</stringProp>
        <longProp name="ThreadGroup.start_time">1481619822000</longProp>
        <longProp name="ThreadGroup.end_time">1481619822000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
          <collectionProp name="Arguments.arguments">
            <elementProp name="CsvSMS1" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS1</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="CsvSMS2" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS2</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="ErrorCode" elementType="Argument">
              <stringProp name="Argument.name">ErrorCode</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="Analysis" elementType="Argument">
              <stringProp name="Argument.name">Analysis</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
          </collectionProp>
        </Arguments>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Cancel Using batchID http request" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;loginId&quot;:&quot;${loginId}&quot;,&quot;password&quot;:&quot;${password}&quot;,&quot;type&quot;:&quot;${viewcancelMSISDNType}&quot;,&quot;data&quot;:{&quot;loginId&quot;:&quot;${userLoginID}&quot;,&quot;batchID&quot;:&quot;${BATCHID}&quot;,&quot;mobileNumbers&quot;:&quot;${MOBILENUMBER}&quot;}}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${host}</stringProp>
          <stringProp name="HTTPSampler.port">${port}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol">${protocol}</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${path}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree/>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Result Writer" enabled="false">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.util.List;
import java.util.ArrayList;

import com.univocity.parsers.common.processor.RowListProcessor;
import com.univocity.parsers.csv.CsvParser;
import com.univocity.parsers.csv.CsvParserSettings;
import com.univocity.parsers.csv.CsvWriter;
import com.univocity.parsers.csv.CsvWriterSettings;

JSONObject jsonObject = new JSONObject();
JSONParser jsonParser = new JSONParser();

String jsonString = prev.getResponseDataAsString();

jsonObject = (JSONObject) jsonParser.parse(jsonString);

vars.put(&quot;statusCode&quot;, jsonObject.get(&quot;statusCode&quot;).toString());
vars.put(&quot;status&quot;, jsonObject.get(&quot;status&quot;).toString());


if(vars.get(&quot;statusCode&quot;).equalsIgnoreCase(&quot;200&quot;) &amp;&amp; vars.get(&quot;status&quot;).equalsIgnoreCase(&quot;true&quot;)){
	log.info(&quot;File Path is &gt;&gt;&gt; &quot; + jsonObject.get(&quot;dataObject&quot;).toString());
	vars.put(&quot;downloadedTemplatePath&quot;, jsonObject.get(&quot;dataObject&quot;).toString());
}else{
	log.info(jsonObject.get(&quot;formError&quot;).toString());
}

FileReader fileReader = new FileReader(vars.get(&quot;downloadedTemplatePath&quot;).toString());
CsvParserSettings parserSettings = new CsvParserSettings();
parserSettings.setLineSeparatorDetectionEnabled(true);

RowListProcessor processor = new RowListProcessor();
parserSettings.setProcessor(processor);
parserSettings.setHeaderExtractionEnabled(true);
parserSettings.setSkipEmptyLines(false);
CsvParser parser = new CsvParser(parserSettings);
parser.parse(fileReader);
List rows = new ArrayList();
rows = processor.getRows();

log.info(&quot;Total no of rows is &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot; + rows.size().toString());

File outputFile = new File(vars.get(&quot;downloadedTemplatePath&quot;).toString());

List finalData = new ArrayList();

for (int k = 0; k&lt; rows.size(); k++) {
	String[] row = (String[])rows.get(k);
	int length = row.length+1;
	String[] data = new String[length];
	int min = Integer.parseInt(row[3]);
	int max = Integer.parseInt(row[4]);
	for (int i = 0; i &lt; row.length; i++) {
		data[i] = row[i];
	}
				
	int amount = min + (int)(Math.random() * ((max - min) + 1));
	data[row.length] = Integer.toString(amount);
	finalData.add(data);
}


String[] header = new String[]{&quot;Mobile number*&quot;,&quot;Subscriber ID*&quot;,&quot;Subscriber name*&quot;,&quot;Minimum transaction amount*&quot;,&quot;Maximum transaction amount*&quot;,&quot;Monthly limit*&quot;,&quot;Used limit*&quot;,&quot;Sub-service *&quot;,&quot;Requested amount*&quot;};
		
Writer writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outputFile)));
CsvWriterSettings settings = new CsvWriterSettings();
CsvWriter csvWriter = new CsvWriter(writer, settings);
StringBuilder row = new StringBuilder();
for (String column : header) {
	if (row.length() &gt; 0) {
		row.append(&quot;,&quot;);
	}
	row.append(column);
}
csvWriter.writeRow(row.toString());

for (String[] object : finalData) {
	StringBuilder row2 = new StringBuilder();
	for (String column : object) {
		if (row2.length() &gt; 0) {
			row2.append(&quot;,&quot;);
		}
		row2.append(column);
	}
	csvWriter.writeRow(row2.toString());
}

csvWriter.close();
String inputFileString = vars.get(&quot;downloadedTemplatePath&quot;).toString().replace(&quot;\\&quot;, &quot;/&quot;);
vars.put(&quot;inputFile&quot;, inputFileString);
vars.put(&quot;noOfRecords&quot;, rows.size().toString());</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
        <CSVDataSet guiclass="TestBeanGUI" testclass="CSVDataSet" testname="CSV Data set config" enabled="true">
          <stringProp name="filename">${CSV path}/CANCEL_SCHEDULE_VIEW_BATCH_MSISDN_DETAIL_NEGATIVE.csv</stringProp>
          <stringProp name="fileEncoding"></stringProp>
          <stringProp name="variableNames"></stringProp>
          <stringProp name="delimiter">,</stringProp>
          <boolProp name="quotedData">false</boolProp>
          <boolProp name="recycle">true</boolProp>
          <boolProp name="stopThread">false</boolProp>
          <stringProp name="shareMode">shareMode.all</stringProp>
        </CSVDataSet>
        <hashTree/>
        <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Request Reader" enabled="true">
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="script">//-- SKD
// -- updating the variables
var sampler = ctx.getCurrentSampler();
var Arguments = sampler.getArguments();
vars.put(&quot;CsvRequest&quot;,&quot;Request&quot;+Arguments);</stringProp>
        </BeanShellPreProcessor>
        <hashTree/>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Result Writer" enabled="true">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.JSONArray;


String jsonString = prev.getResponseDataAsString();

JSONObject jsonObject = new JSONObject();
JSONParser jsonParser = new JSONParser();

jsonObject = (JSONObject) jsonParser.parse(jsonString);
String statusCodeReq = jsonObject.get(&quot;statusCode&quot;).toString();
String status = jsonObject.get(&quot;status&quot;).toString();
JSONObject dataObject = (JSONArray) jsonObject.get(&quot;dataObject&quot;);


String statusCode = &quot;&quot;;
if(statusCodeReq.equalsIgnoreCase(&quot;400&quot;) &amp;&amp; status.equalsIgnoreCase(&quot;false&quot;)){
	statusCode = &quot;Pass&quot;;
}else{
	statusCode = &quot;Fail&quot;;
}


String TestCaseID = vars.get(&quot;TestcaseId&quot;);//argument name must be same as defined in csv file
String Module = vars.get(&quot;Module&quot;);//argument name must be same as defined in csv file
String Description = vars.get(&quot;Description&quot;);//argument name must be same as defined in csv file
String CsvRequest = vars.get(&quot;CsvRequest&quot;);
String SVNRepositoryID = vars.get(&quot;SVNRepositoryID&quot;);
String LeadName = vars.get(&quot;LeadName&quot;);
String TestFrameworkIP = vars.get(&quot;TestFrameworkIP&quot;);
String TestFrameworkName = vars.get(&quot;TestFrameworkName&quot;);
String TestFrameworkSVNPath = vars.get(&quot;TestFrameworkSVNPath&quot;);
String TestExecutionDateTime = vars.get(&quot;TestExecutionDateTime&quot;);
String ProductInterface = vars.get(&quot;ProductInterface&quot;);
String CsvSMS1 = vars.get(&quot;CsvSMS1&quot;);
String CsvSMS2 = vars.get(&quot;CsvSMS2&quot;);
String ErrorCode= vars.get(&quot;ErrorCode&quot;);
String Analysis= vars.get(&quot;Analysis&quot;);
String DumpData= vars.get(&quot;DumpData&quot;);

log.info(SVNRepositoryID);
log.info(LeadName);
log.info(ProductInterface);
PrintData=&quot;&quot;+SVNRepositoryID+&quot;|&quot;+LeadName+&quot;|&quot;+TestFrameworkIP+&quot;|&quot;+TestFrameworkName+&quot;|&quot;+TestFrameworkSVNPath+&quot;|&quot;+TestExecutionDateTime+&quot;|&quot;+ProductInterface+&quot;|&quot;+TestCaseID+&quot;|&quot;+Module+&quot;|&quot;+Description+&quot;|&quot;+CsvRequest+&quot;|&quot;+jsonString+&quot;|&quot;+DumpData+&quot;|&quot;+CsvSMS1+&quot;|&quot;+CsvSMS2+&quot;|&quot;+statusCode+&quot;|&quot;+ErrorCode;


log.info(PrintData);
String resultcsvpath = vars.get(&quot;ResultCsvPath&quot;);
f = new FileOutputStream(resultcsvpath,  true);
p = new PrintStream(f); 
this.interpreter.setOut(p); 
print(PrintData);
f.close();
</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Cancel Schedule Recharge Single Positive Scenario" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">0</stringProp>
        <longProp name="ThreadGroup.start_time">1481619822000</longProp>
        <longProp name="ThreadGroup.end_time">1481619822000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
          <collectionProp name="Arguments.arguments">
            <elementProp name="CsvSMS1" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS1</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="CsvSMS2" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS2</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="ErrorCode" elementType="Argument">
              <stringProp name="Argument.name">ErrorCode</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="Analysis" elementType="Argument">
              <stringProp name="Argument.name">Analysis</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
          </collectionProp>
        </Arguments>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Cancel Using batchID http request" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;loginId&quot;:&quot;${loginId}&quot;,&quot;password&quot;:&quot;${password}&quot;,&quot;type&quot;:&quot;${cancelType}&quot;,&quot;data&quot;:{&quot;loginId&quot;:&quot;${userLoginID}&quot;,&quot;batchID&quot;:&quot;${__property(BATCHID)}&quot;,&quot;checklist&quot;:[&quot;${__property(MOBILENUMBER)}&quot;]}}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${host}</stringProp>
          <stringProp name="HTTPSampler.port">${port}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol">${protocol}</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${path}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree/>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Result Writer" enabled="false">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.util.List;
import java.util.ArrayList;

import com.univocity.parsers.common.processor.RowListProcessor;
import com.univocity.parsers.csv.CsvParser;
import com.univocity.parsers.csv.CsvParserSettings;
import com.univocity.parsers.csv.CsvWriter;
import com.univocity.parsers.csv.CsvWriterSettings;

JSONObject jsonObject = new JSONObject();
JSONParser jsonParser = new JSONParser();

String jsonString = prev.getResponseDataAsString();

jsonObject = (JSONObject) jsonParser.parse(jsonString);

vars.put(&quot;statusCode&quot;, jsonObject.get(&quot;statusCode&quot;).toString());
vars.put(&quot;status&quot;, jsonObject.get(&quot;status&quot;).toString());


if(vars.get(&quot;statusCode&quot;).equalsIgnoreCase(&quot;200&quot;) &amp;&amp; vars.get(&quot;status&quot;).equalsIgnoreCase(&quot;true&quot;)){
	log.info(&quot;File Path is &gt;&gt;&gt; &quot; + jsonObject.get(&quot;dataObject&quot;).toString());
	vars.put(&quot;downloadedTemplatePath&quot;, jsonObject.get(&quot;dataObject&quot;).toString());
}else{
	log.info(jsonObject.get(&quot;formError&quot;).toString());
}

FileReader fileReader = new FileReader(vars.get(&quot;downloadedTemplatePath&quot;).toString());
CsvParserSettings parserSettings = new CsvParserSettings();
parserSettings.setLineSeparatorDetectionEnabled(true);

RowListProcessor processor = new RowListProcessor();
parserSettings.setProcessor(processor);
parserSettings.setHeaderExtractionEnabled(true);
parserSettings.setSkipEmptyLines(false);
CsvParser parser = new CsvParser(parserSettings);
parser.parse(fileReader);
List rows = new ArrayList();
rows = processor.getRows();

log.info(&quot;Total no of rows is &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot; + rows.size().toString());

File outputFile = new File(vars.get(&quot;downloadedTemplatePath&quot;).toString());

List finalData = new ArrayList();

for (int k = 0; k&lt; rows.size(); k++) {
	String[] row = (String[])rows.get(k);
	int length = row.length+1;
	String[] data = new String[length];
	int min = Integer.parseInt(row[3]);
	int max = Integer.parseInt(row[4]);
	for (int i = 0; i &lt; row.length; i++) {
		data[i] = row[i];
	}
				
	int amount = min + (int)(Math.random() * ((max - min) + 1));
	data[row.length] = Integer.toString(amount);
	finalData.add(data);
}


String[] header = new String[]{&quot;Mobile number*&quot;,&quot;Subscriber ID*&quot;,&quot;Subscriber name*&quot;,&quot;Minimum transaction amount*&quot;,&quot;Maximum transaction amount*&quot;,&quot;Monthly limit*&quot;,&quot;Used limit*&quot;,&quot;Sub-service *&quot;,&quot;Requested amount*&quot;};
		
Writer writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outputFile)));
CsvWriterSettings settings = new CsvWriterSettings();
CsvWriter csvWriter = new CsvWriter(writer, settings);
StringBuilder row = new StringBuilder();
for (String column : header) {
	if (row.length() &gt; 0) {
		row.append(&quot;,&quot;);
	}
	row.append(column);
}
csvWriter.writeRow(row.toString());

for (String[] object : finalData) {
	StringBuilder row2 = new StringBuilder();
	for (String column : object) {
		if (row2.length() &gt; 0) {
			row2.append(&quot;,&quot;);
		}
		row2.append(column);
	}
	csvWriter.writeRow(row2.toString());
}

csvWriter.close();
String inputFileString = vars.get(&quot;downloadedTemplatePath&quot;).toString().replace(&quot;\\&quot;, &quot;/&quot;);
vars.put(&quot;inputFile&quot;, inputFileString);
vars.put(&quot;noOfRecords&quot;, rows.size().toString());</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
        <CSVDataSet guiclass="TestBeanGUI" testclass="CSVDataSet" testname="CSV Data set config" enabled="true">
          <stringProp name="filename">${CSV path}/CANCEL_SCHEDULE_RECHARGE_POSITIVE.csv</stringProp>
          <stringProp name="fileEncoding"></stringProp>
          <stringProp name="variableNames"></stringProp>
          <stringProp name="delimiter">,</stringProp>
          <boolProp name="quotedData">false</boolProp>
          <boolProp name="recycle">true</boolProp>
          <boolProp name="stopThread">false</boolProp>
          <stringProp name="shareMode">shareMode.all</stringProp>
        </CSVDataSet>
        <hashTree/>
        <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Request Reader" enabled="true">
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="script">//-- SKD
// -- updating the variables
var sampler = ctx.getCurrentSampler();
var Arguments = sampler.getArguments();
vars.put(&quot;CsvRequest&quot;,&quot;Request&quot;+Arguments);</stringProp>
        </BeanShellPreProcessor>
        <hashTree/>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Result Writer" enabled="true">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.JSONArray;


String jsonString = prev.getResponseDataAsString();

JSONObject jsonObject = new JSONObject();
JSONParser jsonParser = new JSONParser();

jsonObject = (JSONObject) jsonParser.parse(jsonString);
String statusCodeReq = jsonObject.get(&quot;statusCode&quot;).toString();
String status = jsonObject.get(&quot;status&quot;).toString();
JSONObject dataObject =  jsonObject.get(&quot;dataObject&quot;);


String statusCode = &quot;&quot;;
if(statusCodeReq.equalsIgnoreCase(&quot;400&quot;) &amp;&amp; status.equalsIgnoreCase(&quot;false&quot;)){
	statusCode = &quot;Fail&quot;;
}else{
	statusCode = &quot;Pass&quot;;
}


String TestCaseID = vars.get(&quot;TestcaseId&quot;);//argument name must be same as defined in csv file
String Module = vars.get(&quot;Module&quot;);//argument name must be same as defined in csv file
String Description = vars.get(&quot;Description&quot;);//argument name must be same as defined in csv file
String CsvRequest = vars.get(&quot;CsvRequest&quot;);
String SVNRepositoryID = vars.get(&quot;SVNRepositoryID&quot;);
String LeadName = vars.get(&quot;LeadName&quot;);
String TestFrameworkIP = vars.get(&quot;TestFrameworkIP&quot;);
String TestFrameworkName = vars.get(&quot;TestFrameworkName&quot;);
String TestFrameworkSVNPath = vars.get(&quot;TestFrameworkSVNPath&quot;);
String TestExecutionDateTime = vars.get(&quot;TestExecutionDateTime&quot;);
String ProductInterface = vars.get(&quot;ProductInterface&quot;);
String CsvSMS1 = vars.get(&quot;CsvSMS1&quot;);
String CsvSMS2 = vars.get(&quot;CsvSMS2&quot;);
String ErrorCode= vars.get(&quot;ErrorCode&quot;);
String Analysis= vars.get(&quot;Analysis&quot;);
String DumpData= vars.get(&quot;DumpData&quot;);

log.info(SVNRepositoryID);
log.info(LeadName);
log.info(ProductInterface);
PrintData=&quot;&quot;+SVNRepositoryID+&quot;|&quot;+LeadName+&quot;|&quot;+TestFrameworkIP+&quot;|&quot;+TestFrameworkName+&quot;|&quot;+TestFrameworkSVNPath+&quot;|&quot;+TestExecutionDateTime+&quot;|&quot;+ProductInterface+&quot;|&quot;+TestCaseID+&quot;|&quot;+Module+&quot;|&quot;+Description+&quot;|&quot;+CsvRequest+&quot;|&quot;+jsonString+&quot;|&quot;+DumpData+&quot;|&quot;+CsvSMS1+&quot;|&quot;+CsvSMS2+&quot;|&quot;+statusCode+&quot;|&quot;+ErrorCode;


log.info(PrintData);
String resultcsvpath = vars.get(&quot;ResultCsvPath&quot;);
f = new FileOutputStream(resultcsvpath,  true);
p = new PrintStream(f); 
this.interpreter.setOut(p); 
print(PrintData);
f.close();
</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Cancel Schedule Recharge Single Negative Scenario" enabled="false">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">2</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">0</stringProp>
        <longProp name="ThreadGroup.start_time">1481619822000</longProp>
        <longProp name="ThreadGroup.end_time">1481619822000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
          <collectionProp name="Arguments.arguments">
            <elementProp name="CsvSMS1" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS1</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="CsvSMS2" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS2</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="ErrorCode" elementType="Argument">
              <stringProp name="Argument.name">ErrorCode</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="Analysis" elementType="Argument">
              <stringProp name="Argument.name">Analysis</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
          </collectionProp>
        </Arguments>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Cancel Using batchID http request" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;loginId&quot;:&quot;${loginId}&quot;,&quot;password&quot;:&quot;${password}&quot;,&quot;type&quot;:&quot;${cancelType}&quot;,&quot;data&quot;:{&quot;loginId&quot;:&quot;${userLoginID}&quot;,&quot;batchID&quot;:&quot;${BATCHID}&quot;,&quot;checklist&quot;:[&quot;${MOBILENUMBER}&quot;]}}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${host}</stringProp>
          <stringProp name="HTTPSampler.port">${port}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol">${protocol}</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${path}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree/>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Result Writer" enabled="false">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.util.List;
import java.util.ArrayList;

import com.univocity.parsers.common.processor.RowListProcessor;
import com.univocity.parsers.csv.CsvParser;
import com.univocity.parsers.csv.CsvParserSettings;
import com.univocity.parsers.csv.CsvWriter;
import com.univocity.parsers.csv.CsvWriterSettings;

JSONObject jsonObject = new JSONObject();
JSONParser jsonParser = new JSONParser();

String jsonString = prev.getResponseDataAsString();

jsonObject = (JSONObject) jsonParser.parse(jsonString);

vars.put(&quot;statusCode&quot;, jsonObject.get(&quot;statusCode&quot;).toString());
vars.put(&quot;status&quot;, jsonObject.get(&quot;status&quot;).toString());


if(vars.get(&quot;statusCode&quot;).equalsIgnoreCase(&quot;200&quot;) &amp;&amp; vars.get(&quot;status&quot;).equalsIgnoreCase(&quot;true&quot;)){
	log.info(&quot;File Path is &gt;&gt;&gt; &quot; + jsonObject.get(&quot;dataObject&quot;).toString());
	vars.put(&quot;downloadedTemplatePath&quot;, jsonObject.get(&quot;dataObject&quot;).toString());
}else{
	log.info(jsonObject.get(&quot;formError&quot;).toString());
}

FileReader fileReader = new FileReader(vars.get(&quot;downloadedTemplatePath&quot;).toString());
CsvParserSettings parserSettings = new CsvParserSettings();
parserSettings.setLineSeparatorDetectionEnabled(true);

RowListProcessor processor = new RowListProcessor();
parserSettings.setProcessor(processor);
parserSettings.setHeaderExtractionEnabled(true);
parserSettings.setSkipEmptyLines(false);
CsvParser parser = new CsvParser(parserSettings);
parser.parse(fileReader);
List rows = new ArrayList();
rows = processor.getRows();

log.info(&quot;Total no of rows is &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot; + rows.size().toString());

File outputFile = new File(vars.get(&quot;downloadedTemplatePath&quot;).toString());

List finalData = new ArrayList();

for (int k = 0; k&lt; rows.size(); k++) {
	String[] row = (String[])rows.get(k);
	int length = row.length+1;
	String[] data = new String[length];
	int min = Integer.parseInt(row[3]);
	int max = Integer.parseInt(row[4]);
	for (int i = 0; i &lt; row.length; i++) {
		data[i] = row[i];
	}
				
	int amount = min + (int)(Math.random() * ((max - min) + 1));
	data[row.length] = Integer.toString(amount);
	finalData.add(data);
}


String[] header = new String[]{&quot;Mobile number*&quot;,&quot;Subscriber ID*&quot;,&quot;Subscriber name*&quot;,&quot;Minimum transaction amount*&quot;,&quot;Maximum transaction amount*&quot;,&quot;Monthly limit*&quot;,&quot;Used limit*&quot;,&quot;Sub-service *&quot;,&quot;Requested amount*&quot;};
		
Writer writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outputFile)));
CsvWriterSettings settings = new CsvWriterSettings();
CsvWriter csvWriter = new CsvWriter(writer, settings);
StringBuilder row = new StringBuilder();
for (String column : header) {
	if (row.length() &gt; 0) {
		row.append(&quot;,&quot;);
	}
	row.append(column);
}
csvWriter.writeRow(row.toString());

for (String[] object : finalData) {
	StringBuilder row2 = new StringBuilder();
	for (String column : object) {
		if (row2.length() &gt; 0) {
			row2.append(&quot;,&quot;);
		}
		row2.append(column);
	}
	csvWriter.writeRow(row2.toString());
}

csvWriter.close();
String inputFileString = vars.get(&quot;downloadedTemplatePath&quot;).toString().replace(&quot;\\&quot;, &quot;/&quot;);
vars.put(&quot;inputFile&quot;, inputFileString);
vars.put(&quot;noOfRecords&quot;, rows.size().toString());</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
        <CSVDataSet guiclass="TestBeanGUI" testclass="CSVDataSet" testname="CSV Data set config" enabled="true">
          <stringProp name="filename">${CSV path}/CANCEL_SCHEDULE_RECHARGE_NEGATIVE.csv</stringProp>
          <stringProp name="fileEncoding"></stringProp>
          <stringProp name="variableNames"></stringProp>
          <stringProp name="delimiter">,</stringProp>
          <boolProp name="quotedData">false</boolProp>
          <boolProp name="recycle">true</boolProp>
          <boolProp name="stopThread">false</boolProp>
          <stringProp name="shareMode">shareMode.all</stringProp>
        </CSVDataSet>
        <hashTree/>
        <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Request Reader" enabled="true">
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="script">//-- SKD
// -- updating the variables
var sampler = ctx.getCurrentSampler();
var Arguments = sampler.getArguments();
vars.put(&quot;CsvRequest&quot;,&quot;Request&quot;+Arguments);</stringProp>
        </BeanShellPreProcessor>
        <hashTree/>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Result Writer" enabled="true">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.JSONArray;


String jsonString = prev.getResponseDataAsString();

JSONObject jsonObject = new JSONObject();
JSONParser jsonParser = new JSONParser();

jsonObject = (JSONObject) jsonParser.parse(jsonString);
String statusCodeReq = jsonObject.get(&quot;statusCode&quot;).toString();
String status = jsonObject.get(&quot;status&quot;).toString();
JSONObject dataObject = (JSONArray) jsonObject.get(&quot;dataObject&quot;);


String statusCode = &quot;&quot;;
if(statusCodeReq.equalsIgnoreCase(&quot;400&quot;) &amp;&amp; status.equalsIgnoreCase(&quot;false&quot;)){
	statusCode = &quot;Pass&quot;;
}else{
	statusCode = &quot;Fail&quot;;
}

String TestCaseID = vars.get(&quot;TestcaseId&quot;);//argument name must be same as defined in csv file
String Module = vars.get(&quot;Module&quot;);//argument name must be same as defined in csv file
String Description = vars.get(&quot;Description&quot;);//argument name must be same as defined in csv file
String CsvRequest = vars.get(&quot;CsvRequest&quot;);
String SVNRepositoryID = vars.get(&quot;SVNRepositoryID&quot;);
String LeadName = vars.get(&quot;LeadName&quot;);
String TestFrameworkIP = vars.get(&quot;TestFrameworkIP&quot;);
String TestFrameworkName = vars.get(&quot;TestFrameworkName&quot;);
String TestFrameworkSVNPath = vars.get(&quot;TestFrameworkSVNPath&quot;);
String TestExecutionDateTime = vars.get(&quot;TestExecutionDateTime&quot;);
String ProductInterface = vars.get(&quot;ProductInterface&quot;);
String CsvSMS1 = vars.get(&quot;CsvSMS1&quot;);
String CsvSMS2 = vars.get(&quot;CsvSMS2&quot;);
String ErrorCode= vars.get(&quot;ErrorCode&quot;);
String Analysis= vars.get(&quot;Analysis&quot;);
String DumpData= vars.get(&quot;DumpData&quot;);

log.info(SVNRepositoryID);
log.info(LeadName);
log.info(ProductInterface);
PrintData=&quot;&quot;+SVNRepositoryID+&quot;|&quot;+LeadName+&quot;|&quot;+TestFrameworkIP+&quot;|&quot;+TestFrameworkName+&quot;|&quot;+TestFrameworkSVNPath+&quot;|&quot;+TestExecutionDateTime+&quot;|&quot;+ProductInterface+&quot;|&quot;+TestCaseID+&quot;|&quot;+Module+&quot;|&quot;+Description+&quot;|&quot;+CsvRequest+&quot;|&quot;+jsonString+&quot;|&quot;+DumpData+&quot;|&quot;+CsvSMS1+&quot;|&quot;+CsvSMS2+&quot;|&quot;+statusCode+&quot;|&quot;+ErrorCode;


log.info(PrintData);
String resultcsvpath = vars.get(&quot;ResultCsvPath&quot;);
f = new FileOutputStream(resultcsvpath,  true);
p = new PrintStream(f); 
this.interpreter.setOut(p); 
print(PrintData);
f.close();
</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Batch Re-Schedule Recharge Positive Scenario" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">0</stringProp>
        <longProp name="ThreadGroup.start_time">1481619893000</longProp>
        <longProp name="ThreadGroup.end_time">1481619893000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
          <collectionProp name="Arguments.arguments">
            <elementProp name="CsvSMS1" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS1</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="CsvSMS2" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS2</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="ErrorCode" elementType="Argument">
              <stringProp name="Argument.name">ErrorCode</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="Analysis" elementType="Argument">
              <stringProp name="Argument.name">Analysis</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
          </collectionProp>
        </Arguments>
        <hashTree/>
        <CSVDataSet guiclass="TestBeanGUI" testclass="CSVDataSet" testname="CSV Data set config" enabled="true">
          <stringProp name="filename">${CSV path}/BATCH_RESCHEDULE_POSITIVE_FLOW.csv</stringProp>
          <stringProp name="fileEncoding"></stringProp>
          <stringProp name="variableNames"></stringProp>
          <stringProp name="delimiter">,</stringProp>
          <boolProp name="quotedData">false</boolProp>
          <boolProp name="recycle">true</boolProp>
          <boolProp name="stopThread">false</boolProp>
          <stringProp name="shareMode">shareMode.all</stringProp>
        </CSVDataSet>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Load scheduled batch list Request  " enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;loginId&quot;:&quot;${loginId}&quot;,&quot;password&quot;:&quot;${password}&quot;,&quot;data&quot;:{&quot;userID&quot;:&quot;${USER_ID}&quot;,&quot;serviceCode&quot;:&quot;${serviceCode}&quot;},&quot;type&quot;:&quot;LOADBATCHLIST&quot;}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${host}</stringProp>
          <stringProp name="HTTPSampler.port">${port}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol">${protocol}</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${path}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree/>
        <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Request Reader" enabled="true">
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="script">//-- SKD
// -- updating the valiables
var sampler = ctx.getCurrentSampler();
var Arguments = sampler.getArguments();
vars.put(&quot;CsvRequest&quot;,&quot;Request&quot;+Arguments);</stringProp>
        </BeanShellPreProcessor>
        <hashTree/>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Load scheduled batch list Response Result Writer" enabled="true">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.apache.jmeter.util.JMeterUtils;

String jsonString = prev.getResponseDataAsString();
log.info(&quot;Load scheduled batch list  Response jsonString:&quot;+jsonString);
JSONObject jsonObject = new JSONObject();
JSONParser jsonParser = new JSONParser();

jsonObject = (JSONObject) jsonParser.parse(jsonString);
String statusCodeReq = jsonObject.get(&quot;statusCode&quot;).toString();
String status = jsonObject.get(&quot;status&quot;).toString();
String statusCode = &quot;&quot;;
String TestcaseType = vars.get(&quot;TestcaseType&quot;);
if(statusCodeReq.equalsIgnoreCase(&quot;200&quot;) &amp;&amp; status.equalsIgnoreCase(&quot;true&quot;)){
	statusCode = &quot;Pass&quot;;
	String userID = jsonObject.get(&quot;dataObject&quot;).get(&quot;userID&quot;);
	String serviceCode = jsonObject.get(&quot;dataObject&quot;).get(&quot;serviceCode&quot;);
	String batchID = jsonObject.get(&quot;dataObject&quot;).get(&quot;scheduleList&quot;).get(0).get(&quot;batchID&quot;).toString();
	String fileType = jsonObject.get(&quot;dataObject&quot;).get(&quot;scheduleList&quot;).get(0).get(&quot;batchType&quot;).toString();

	
	vars.put(&quot;USER_ID&quot;, userID);
	vars.put(&quot;SERVICE_CODE&quot;, serviceCode);
	vars.put(&quot;BATCH_ID&quot;, batchID);
	vars.put(&quot;FILE_TYPE&quot;, fileType);

	log.info(&quot;userID: &quot;+userID+&quot; serviceCode:&quot;+serviceCode+&quot; batchID:&quot;+batchID+&quot; fileType:&quot;+fileType);

	log.info(&quot;::Load scheduled batch list Request completed::&quot;);
	log.info(&quot;::Download Batch File Request Started::&quot;);
}else{
	if(TestcaseType.equalsIgnoreCase(&quot;NEGATIVE&quot;)){
		statusCode = &quot;Pass&quot;;
	}else{
		statusCode = &quot;Fail&quot;;


String TestCaseID = vars.get(&quot;TestcaseId&quot;);//argument name must be same as defined in csv file
String Module = vars.get(&quot;Module&quot;);//argument name must be same as defined in csv file
String Description = vars.get(&quot;Description&quot;);//argument name must be same as defined in csv file
String CsvRequest = vars.get(&quot;CsvRequest&quot;);
String SVNRepositoryID = vars.get(&quot;SVNRepositoryID&quot;);
String LeadName = vars.get(&quot;LeadName&quot;);
String TestFrameworkIP = vars.get(&quot;TestFrameworkIP&quot;);
String TestFrameworkName = vars.get(&quot;TestFrameworkName&quot;);
String TestFrameworkSVNPath = vars.get(&quot;TestFrameworkSVNPath&quot;);
String TestExecutionDateTime = vars.get(&quot;TestExecutionDateTime&quot;);
String ProductInterface = vars.get(&quot;ProductInterface&quot;);
String CsvSMS1 = vars.get(&quot;CsvSMS1&quot;);
String CsvSMS2 = vars.get(&quot;CsvSMS2&quot;);
String ErrorCode= vars.get(&quot;ErrorCode&quot;);
String Analysis= vars.get(&quot;Analysis&quot;);
String DumpData= vars.get(&quot;DumpData&quot;);

log.info(SVNRepositoryID);
log.info(LeadName);
log.info(ProductInterface);
PrintData=&quot;&quot;+SVNRepositoryID+&quot;|&quot;+LeadName+&quot;|&quot;+TestFrameworkIP+&quot;|&quot;+TestFrameworkName+&quot;|&quot;+TestFrameworkSVNPath+&quot;|&quot;+TestExecutionDateTime+&quot;|&quot;+ProductInterface+&quot;|&quot;+TestCaseID+&quot;|&quot;+Module+&quot;|&quot;+Description+&quot;|&quot;+CsvRequest+&quot;|&quot;+jsonString+&quot;|&quot;+DumpData+&quot;|&quot;+CsvSMS1+&quot;|&quot;+CsvSMS2+&quot;|&quot;+statusCode+&quot;|&quot;+ErrorCode;
		
		log.info(&quot;Load scheduled batch list Request got failed&quot;);
		
		log.info(PrintData);
		String resultcsvpath = vars.get(&quot;ResultCsvPath&quot;);
		f = new FileOutputStream(resultcsvpath,  true);
		p = new PrintStream(f); 
		this.interpreter.setOut(p); 
		print(PrintData);
		f.close();
		
	}	
}
</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Download Batch File Request" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;loginId&quot;:&quot;${loginId}&quot;,&quot;password&quot;:&quot;${password}&quot;,&quot;data&quot;:{&quot;userID&quot;:&quot;${USER_ID}&quot;,&quot;fileType&quot;:&quot;${FILE_TYPE}&quot;,&quot;batchID&quot;:&quot;${BATCH_ID}&quot;,&quot;serviceCode&quot;:&quot;${serviceCode}&quot;},&quot;type&quot;:&quot;DWNLDBATCHFILE&quot;}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${host}</stringProp>
          <stringProp name="HTTPSampler.port">${port}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol">${protocol}</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${path}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Download Batch File Response Result Writer" enabled="true">
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import java.util.Date;
import java.text.SimpleDateFormat; 
import org.apache.jmeter.util.JMeterUtils;

import java.io.FileReader;

import java.util.List;
import java.util.ArrayList;

import com.univocity.parsers.common.processor.RowListProcessor;
import com.univocity.parsers.csv.CsvParser;
import com.univocity.parsers.csv.CsvParserSettings;


String jsonString = prev.getResponseDataAsString();
log.info(&quot;Download Batch File Response jsonString:&quot;+jsonString);
JSONObject jsonObject = new JSONObject();
JSONParser jsonParser = new JSONParser();

jsonObject = (JSONObject) jsonParser.parse(jsonString);
String statusCodeReq = jsonObject.get(&quot;statusCode&quot;).toString();
String status = jsonObject.get(&quot;status&quot;).toString();
String statusCode = &quot;&quot;;
String TestcaseType = vars.get(&quot;TestcaseType&quot;);
if(statusCodeReq.equalsIgnoreCase(&quot;200&quot;) &amp;&amp; status.equalsIgnoreCase(&quot;true&quot;)){
	statusCode = &quot;Pass&quot;;
	String downloadFilePath = jsonObject.get(&quot;dataObject&quot;).get(&quot;downloadFilePath&quot;);
	downloadFilePath = downloadFilePath.replace(&quot;\\&quot;, &quot;\\\\&quot;);
	//Making current date as schedule date
	Date date = new Date(); 
	SimpleDateFormat df  = new SimpleDateFormat(&quot;dd/MM/yy&quot;); 
	String formattedDate = df.format(date); 

	FileReader fileReader = new FileReader(downloadFilePath);
	CsvParserSettings parserSettings = new CsvParserSettings();
	parserSettings.setLineSeparatorDetectionEnabled(true);

	RowListProcessor processor = new RowListProcessor();
	parserSettings.setProcessor(processor);
	//parserSettings.setHeaderExtractionEnabled(true);
	parserSettings.setSkipEmptyLines(false);
	parserSettings.setNumberOfRowsToSkip(2);
	CsvParser parser = new CsvParser(parserSettings);
	parser.parse(fileReader);
	List rows = new ArrayList();
	rows = processor.getRows();
	String noOfRecords = rows.size().toString();

	log.info(&quot;UPLOAD_PATH: &quot;+downloadFilePath+&quot; SCHEDULE_DATE: &quot;+formattedDate+&quot; noOfRecords : &quot; + noOfRecords);
	
	vars.put(&quot;UPLOAD_PATH&quot;, downloadFilePath);
	vars.put(&quot;SCHEDULE_DATE&quot;, formattedDate);
	vars.put(&quot;NO_OF_RECORDS&quot;, noOfRecords);
	vars.put(&quot;REQUEST_FOR&quot;, &quot;reschedule&quot;);
	
	log.info(&quot;::Download Batch File Request Completed::&quot;);
	log.info(&quot;::Re-schedule Recharge Request Started::&quot;);

}else{
	if(TestcaseType.equalsIgnoreCase(&quot;NEGATIVE&quot;)){
		statusCode = &quot;Pass&quot;;
	}else{
		statusCode = &quot;Fail&quot;;
String TestCaseID = vars.get(&quot;TestcaseId&quot;);//argument name must be same as defined in csv file
String Module = vars.get(&quot;Module&quot;);//argument name must be same as defined in csv file
String Description = vars.get(&quot;Description&quot;);//argument name must be same as defined in csv file
String CsvRequest = vars.get(&quot;CsvRequest&quot;);
String SVNRepositoryID = vars.get(&quot;SVNRepositoryID&quot;);
String LeadName = vars.get(&quot;LeadName&quot;);
String TestFrameworkIP = vars.get(&quot;TestFrameworkIP&quot;);
String TestFrameworkName = vars.get(&quot;TestFrameworkName&quot;);
String TestFrameworkSVNPath = vars.get(&quot;TestFrameworkSVNPath&quot;);
String TestExecutionDateTime = vars.get(&quot;TestExecutionDateTime&quot;);
String ProductInterface = vars.get(&quot;ProductInterface&quot;);
String CsvSMS1 = vars.get(&quot;CsvSMS1&quot;);
String CsvSMS2 = vars.get(&quot;CsvSMS2&quot;);
String ErrorCode= vars.get(&quot;ErrorCode&quot;);
String Analysis= vars.get(&quot;Analysis&quot;);
String DumpData= vars.get(&quot;DumpData&quot;);

log.info(SVNRepositoryID);
log.info(LeadName);
log.info(ProductInterface);
PrintData=&quot;&quot;+SVNRepositoryID+&quot;|&quot;+LeadName+&quot;|&quot;+TestFrameworkIP+&quot;|&quot;+TestFrameworkName+&quot;|&quot;+TestFrameworkSVNPath+&quot;|&quot;+TestExecutionDateTime+&quot;|&quot;+ProductInterface+&quot;|&quot;+TestCaseID+&quot;|&quot;+Module+&quot;|&quot;+Description+&quot;|&quot;+CsvRequest+&quot;|&quot;+jsonString+&quot;|&quot;+DumpData+&quot;|&quot;+CsvSMS1+&quot;|&quot;+CsvSMS2+&quot;|&quot;+statusCode+&quot;|&quot;+ErrorCode;
		
		log.info(&quot;Load scheduled batch list Request got failed&quot;);
		
		log.info(PrintData);
		String resultcsvpath = vars.get(&quot;ResultCsvPath&quot;);
		f = new FileOutputStream(resultcsvpath,  true);
		p = new PrintStream(f); 
		this.interpreter.setOut(p); 
		print(PrintData);
		f.close();
		
	}	
}	



</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Re-schedule Recharge Request" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;loginId&quot;:&quot;${loginId}&quot;,&quot;password&quot;:&quot;${password}&quot;,&quot;data&quot;:{&quot;categoryCode&quot;:&quot;${categoryCode}&quot;,&quot;userID&quot;:&quot;${USER_ID}&quot;,&quot;domainCode&quot;:&quot;${domainCode}&quot;,&quot;serviceCode&quot;:&quot;${serviceCode}&quot;,&quot;scheduleDate&quot;:&quot;${SCHEDULE_DATE}&quot;,&quot;noOfRecords&quot;:&quot;${NO_OF_RECORDS}&quot;,&quot;requestFor&quot;:&quot;${REQUEST_FOR}&quot;,&quot;batchID&quot;:&quot;${BATCH_ID}&quot;,&quot;iterations&quot;:&quot;${iterations}&quot;,&quot;frequencyCode&quot;:&quot;${frequencyCode}&quot;,&quot;uploadFilePath&quot;:&quot;${UPLOAD_PATH}&quot;},&quot;type&quot;:&quot;PROCESSRESCHDL&quot;}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${host}</stringProp>
          <stringProp name="HTTPSampler.port">${port}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol">${protocol}</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${path}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree/>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Re-schedule Recharge Response Result Writer" enabled="true">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.apache.jmeter.util.JMeterUtils;


String CsvRequest = vars.get(&quot;CsvRequest&quot;);
log.info(&quot;Re-schedule Recharge  Request jsonString:&quot;+CsvRequest);
String jsonString = prev.getResponseDataAsString();
log.info(&quot;Re-schedule Recharge  Response jsonString:&quot;+jsonString);
JSONObject jsonObject = new JSONObject();
JSONParser jsonParser = new JSONParser();

jsonObject = (JSONObject) jsonParser.parse(jsonString);
String statusCodeReq = jsonObject.get(&quot;statusCode&quot;).toString();
String status = jsonObject.get(&quot;status&quot;).toString();
String statusCode = &quot;&quot;;
String TestcaseType = vars.get(&quot;TestcaseType&quot;);
String newBatchID = &quot;&quot;;
if(statusCodeReq.equalsIgnoreCase(&quot;200&quot;) &amp;&amp; status.equalsIgnoreCase(&quot;true&quot;)){
	statusCode = &quot;Pass&quot;;
	newBatchID = jsonObject.get(&quot;parameters&quot;).get(0);
	vars.put(&quot;newBatch&quot;,newBatchID);
	log.info(&quot;newBatchID: &quot;+newBatchID);

}else{
	if(TestcaseType.equalsIgnoreCase(&quot;NEGATIVE&quot;)){
		statusCode = &quot;Pass&quot;;
	}else{
		statusCode = &quot;Fail&quot;;
	}	
}

log.info(&quot;::Re-schedule Recharge  Request Completed::&quot;);



try{
/*PrintData=&quot;Test case ID:&quot;+TestCaseID+&quot;|Module:&quot;+Module+&quot;|Description:&quot;+Description+&quot;|New Batch ID:&quot;+newBatchID+&quot;|Status:&quot;+statusCode;*/

String TestCaseID = vars.get(&quot;TestcaseId&quot;);//argument name must be same as defined in csv file
String Module = vars.get(&quot;Module&quot;);//argument name must be same as defined in csv file
String Description = vars.get(&quot;Description&quot;);//argument name must be same as defined in csv file
String CsvRequest = vars.get(&quot;CsvRequest&quot;);
String SVNRepositoryID = vars.get(&quot;SVNRepositoryID&quot;);
String LeadName = vars.get(&quot;LeadName&quot;);
String TestFrameworkIP = vars.get(&quot;TestFrameworkIP&quot;);
String TestFrameworkName = vars.get(&quot;TestFrameworkName&quot;);
String TestFrameworkSVNPath = vars.get(&quot;TestFrameworkSVNPath&quot;);
String TestExecutionDateTime = vars.get(&quot;TestExecutionDateTime&quot;);
String ProductInterface = vars.get(&quot;ProductInterface&quot;);
String CsvSMS1 = vars.get(&quot;CsvSMS1&quot;);
String CsvSMS2 = vars.get(&quot;CsvSMS2&quot;);
String ErrorCode= vars.get(&quot;ErrorCode&quot;);
String Analysis= vars.get(&quot;Analysis&quot;);
String DumpData= vars.get(&quot;DumpData&quot;);

log.info(SVNRepositoryID);
log.info(LeadName);
log.info(ProductInterface);
PrintData=&quot;&quot;+SVNRepositoryID+&quot;|&quot;+LeadName+&quot;|&quot;+TestFrameworkIP+&quot;|&quot;+TestFrameworkName+&quot;|&quot;+TestFrameworkSVNPath+&quot;|&quot;+TestExecutionDateTime+&quot;|&quot;+ProductInterface+&quot;|&quot;+TestCaseID+&quot;|&quot;+Module+&quot;|&quot;+Description+&quot;|&quot;+CsvRequest+&quot;|&quot;+jsonString+&quot;|&quot;+DumpData+&quot;|&quot;+CsvSMS1+&quot;|&quot;+CsvSMS2+&quot;|&quot;+statusCode+&quot;|&quot;+ErrorCode;
log.info(PrintData);
String resultcsvpath = vars.get(&quot;ResultCsvPath&quot;);
log.info(&quot;1:&quot;+resultcsvpath);
f = new FileOutputStream(resultcsvpath,  true);
log.info(&quot;2:&quot;+resultcsvpath);
p = new PrintStream(f); 
log.info(&quot;3:&quot;+resultcsvpath);
this.interpreter.setOut(p); 
log.info(&quot;4:&quot;+resultcsvpath);
print(PrintData);
log.info(&quot;5:&quot;+resultcsvpath);
f.close();
}
catch(Throwable ex){
    log.error(&quot;Error in Beanshell&quot;, ex);
    throw ex;
}
</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="GETBATCH" enabled="true">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">${__setProperty(BATCHID,${BATCH})};
</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="GETBATCH" enabled="true">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">${__setProperty(BATCHID,${newBatch})};
</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Batch Re-Schedule Load Batch List Negative Scenario" enabled="false">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">4</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <longProp name="ThreadGroup.start_time">1481619893000</longProp>
        <longProp name="ThreadGroup.end_time">1481619893000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
          <collectionProp name="Arguments.arguments">
            <elementProp name="CsvSMS1" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS1</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="CsvSMS2" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS2</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="ErrorCode" elementType="Argument">
              <stringProp name="Argument.name">ErrorCode</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="Analysis" elementType="Argument">
              <stringProp name="Argument.name">Analysis</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
          </collectionProp>
        </Arguments>
        <hashTree/>
        <CSVDataSet guiclass="TestBeanGUI" testclass="CSVDataSet" testname="CSV Data set config" enabled="true">
          <stringProp name="filename">${CSV path}/BATCH_RESCHEDULE_LOAD_BATCH_LIST_NEGATIVE.csv</stringProp>
          <stringProp name="fileEncoding"></stringProp>
          <stringProp name="variableNames"></stringProp>
          <stringProp name="delimiter">,</stringProp>
          <boolProp name="quotedData">false</boolProp>
          <boolProp name="recycle">true</boolProp>
          <boolProp name="stopThread">false</boolProp>
          <stringProp name="shareMode">shareMode.all</stringProp>
        </CSVDataSet>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="File Upload Http Request" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;loginId&quot;:&quot;${LOGIN_ID}&quot;,&quot;password&quot;:&quot;${PASSWORD}&quot;,&quot;data&quot;:{&quot;userID&quot;:&quot;${USER_ID}&quot;,&quot;serviceCode&quot;:&quot;${SERVICE_CODE}&quot;},&quot;type&quot;:&quot;${TYPE}&quot;}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${host}</stringProp>
          <stringProp name="HTTPSampler.port">${port}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol">${protocol}</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${path}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree/>
        <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Request Reader" enabled="true">
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="script">//-- SKD
// -- updating the valiables
var sampler = ctx.getCurrentSampler();
var Arguments = sampler.getArguments();
vars.put(&quot;CsvRequest&quot;,&quot;Request&quot;+Arguments);</stringProp>
        </BeanShellPreProcessor>
        <hashTree/>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Result Writer" enabled="true">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;

String jsonString = prev.getResponseDataAsString();
log.info(&quot;jsonString:&quot;+jsonString);
JSONObject jsonObject = new JSONObject();
JSONParser jsonParser = new JSONParser();

jsonObject = (JSONObject) jsonParser.parse(jsonString);
String statusCodeReq = jsonObject.get(&quot;statusCode&quot;).toString();
String status = jsonObject.get(&quot;status&quot;).toString();
String statusCode = &quot;&quot;;
String TestcaseType = vars.get(&quot;TestcaseType&quot;);
if(statusCodeReq.equalsIgnoreCase(&quot;200&quot;) &amp;&amp; status.equalsIgnoreCase(&quot;true&quot;)){
	statusCode = &quot;Pass&quot;;
}else{
	if(TestcaseType.equalsIgnoreCase(&quot;NEGATIVE&quot;)){
		statusCode = &quot;Pass&quot;;
	}else{
		statusCode = &quot;Fail&quot;;
	}	
}


String TestCaseID = vars.get(&quot;TestcaseId&quot;);//argument name must be same as defined in csv file
String Module = vars.get(&quot;Module&quot;);//argument name must be same as defined in csv file
String Description = vars.get(&quot;Description&quot;);//argument name must be same as defined in csv file
String CsvRequest = vars.get(&quot;CsvRequest&quot;);
String SVNRepositoryID = vars.get(&quot;SVNRepositoryID&quot;);
String LeadName = vars.get(&quot;LeadName&quot;);
String TestFrameworkIP = vars.get(&quot;TestFrameworkIP&quot;);
String TestFrameworkName = vars.get(&quot;TestFrameworkName&quot;);
String TestFrameworkSVNPath = vars.get(&quot;TestFrameworkSVNPath&quot;);
String TestExecutionDateTime = vars.get(&quot;TestExecutionDateTime&quot;);
String ProductInterface = vars.get(&quot;ProductInterface&quot;);
String CsvSMS1 = vars.get(&quot;CsvSMS1&quot;);
String CsvSMS2 = vars.get(&quot;CsvSMS2&quot;);
String ErrorCode= vars.get(&quot;ErrorCode&quot;);
String Analysis= vars.get(&quot;Analysis&quot;);
String DumpData= vars.get(&quot;DumpData&quot;);

log.info(SVNRepositoryID);
log.info(LeadName);
log.info(ProductInterface);
PrintData=&quot;&quot;+SVNRepositoryID+&quot;|&quot;+LeadName+&quot;|&quot;+TestFrameworkIP+&quot;|&quot;+TestFrameworkName+&quot;|&quot;+TestFrameworkSVNPath+&quot;|&quot;+TestExecutionDateTime+&quot;|&quot;+ProductInterface+&quot;|&quot;+TestCaseID+&quot;|&quot;+Module+&quot;|&quot;+Description+&quot;|&quot;+CsvRequest+&quot;|&quot;+jsonString+&quot;|&quot;+DumpData+&quot;|&quot;+CsvSMS1+&quot;|&quot;+CsvSMS2+&quot;|&quot;+statusCode+&quot;|&quot;+ErrorCode;


log.info(PrintData);
String resultcsvpath = vars.get(&quot;ResultCsvPath&quot;);
f = new FileOutputStream(resultcsvpath,  true);
p = new PrintStream(f); 
this.interpreter.setOut(p); 
print(PrintData);
f.close();</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Batch Re-Schedule download Batch File Negative Scenario" enabled="false">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">6</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <longProp name="ThreadGroup.start_time">1481619893000</longProp>
        <longProp name="ThreadGroup.end_time">1481619893000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
          <collectionProp name="Arguments.arguments">
            <elementProp name="CsvSMS1" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS1</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="CsvSMS2" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS2</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="ErrorCode" elementType="Argument">
              <stringProp name="Argument.name">ErrorCode</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="Analysis" elementType="Argument">
              <stringProp name="Argument.name">Analysis</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
          </collectionProp>
        </Arguments>
        <hashTree/>
        <CSVDataSet guiclass="TestBeanGUI" testclass="CSVDataSet" testname="CSV Data set config" enabled="true">
          <stringProp name="filename">${CSV path}/BATCH_RESCHEDULE_DOWNLOAD_BATCH_FILE_NEGATIVE.csv</stringProp>
          <stringProp name="fileEncoding"></stringProp>
          <stringProp name="variableNames"></stringProp>
          <stringProp name="delimiter">,</stringProp>
          <boolProp name="quotedData">false</boolProp>
          <boolProp name="recycle">true</boolProp>
          <boolProp name="stopThread">false</boolProp>
          <stringProp name="shareMode">shareMode.all</stringProp>
        </CSVDataSet>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="File Upload Http Request" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;loginId&quot;:&quot;${LOGIN_ID}&quot;,&quot;password&quot;:&quot;${PASSWORD}&quot;,&quot;data&quot;:{&quot;userID&quot;:&quot;${USER_ID}&quot;,&quot;fileType&quot;:&quot;${FILE_TYPE}&quot;,&quot;batchID&quot;:&quot;${BATCH_ID}&quot;,&quot;serviceCode&quot;:&quot;${SERVICE_CODE}&quot;},&quot;type&quot;:&quot;${TYPE}&quot;}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${host}</stringProp>
          <stringProp name="HTTPSampler.port">${port}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol">${protocol}</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${path}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree/>
        <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Request Reader" enabled="true">
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="script">//-- SKD
// -- updating the valiables
var sampler = ctx.getCurrentSampler();
var Arguments = sampler.getArguments();
vars.put(&quot;CsvRequest&quot;,&quot;Request&quot;+Arguments);</stringProp>
        </BeanShellPreProcessor>
        <hashTree/>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Result Writer" enabled="true">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;

String jsonString = prev.getResponseDataAsString();
log.info(&quot;jsonString:&quot;+jsonString);
JSONObject jsonObject = new JSONObject();
JSONParser jsonParser = new JSONParser();

jsonObject = (JSONObject) jsonParser.parse(jsonString);
String statusCodeReq = jsonObject.get(&quot;statusCode&quot;).toString();
String status = jsonObject.get(&quot;status&quot;).toString();
String statusCode = &quot;&quot;;
String TestcaseType = vars.get(&quot;TestcaseType&quot;);
if(statusCodeReq.equalsIgnoreCase(&quot;200&quot;) &amp;&amp; status.equalsIgnoreCase(&quot;true&quot;)){
	statusCode = &quot;Pass&quot;;
		String downloadFilePath = jsonObject.get(&quot;dataObject&quot;).get(&quot;downloadFilePath&quot;);
		log.info(&quot;downloadFilePath: &quot;+downloadFilePath);
}else{
	if(TestcaseType.equalsIgnoreCase(&quot;NEGATIVE&quot;)){
		statusCode = &quot;Pass&quot;;
	}else{
		statusCode = &quot;Fail&quot;;
	}	
}


String TestCaseID = vars.get(&quot;TestcaseId&quot;);//argument name must be same as defined in csv file
String Module = vars.get(&quot;Module&quot;);//argument name must be same as defined in csv file
String Description = vars.get(&quot;Description&quot;);//argument name must be same as defined in csv file
String CsvRequest = vars.get(&quot;CsvRequest&quot;);
String SVNRepositoryID = vars.get(&quot;SVNRepositoryID&quot;);
String LeadName = vars.get(&quot;LeadName&quot;);
String TestFrameworkIP = vars.get(&quot;TestFrameworkIP&quot;);
String TestFrameworkName = vars.get(&quot;TestFrameworkName&quot;);
String TestFrameworkSVNPath = vars.get(&quot;TestFrameworkSVNPath&quot;);
String TestExecutionDateTime = vars.get(&quot;TestExecutionDateTime&quot;);
String ProductInterface = vars.get(&quot;ProductInterface&quot;);
String CsvSMS1 = vars.get(&quot;CsvSMS1&quot;);
String CsvSMS2 = vars.get(&quot;CsvSMS2&quot;);
String ErrorCode= vars.get(&quot;ErrorCode&quot;);
String Analysis= vars.get(&quot;Analysis&quot;);
String DumpData= vars.get(&quot;DumpData&quot;);

log.info(SVNRepositoryID);
log.info(LeadName);
log.info(ProductInterface);
PrintData=&quot;&quot;+SVNRepositoryID+&quot;|&quot;+LeadName+&quot;|&quot;+TestFrameworkIP+&quot;|&quot;+TestFrameworkName+&quot;|&quot;+TestFrameworkSVNPath+&quot;|&quot;+TestExecutionDateTime+&quot;|&quot;+ProductInterface+&quot;|&quot;+TestCaseID+&quot;|&quot;+Module+&quot;|&quot;+Description+&quot;|&quot;+CsvRequest+&quot;|&quot;+jsonString+&quot;|&quot;+DumpData+&quot;|&quot;+CsvSMS1+&quot;|&quot;+CsvSMS2+&quot;|&quot;+statusCode+&quot;|&quot;+ErrorCode;


log.info(PrintData);
String resultcsvpath = vars.get(&quot;ResultCsvPath&quot;);
f = new FileOutputStream(resultcsvpath,  true);
p = new PrintStream(f); 
this.interpreter.setOut(p); 
print(PrintData);
f.close();</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Batch Re-Schedule Recharge Process Negative Scenario" enabled="false">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">16</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <longProp name="ThreadGroup.start_time">1481619893000</longProp>
        <longProp name="ThreadGroup.end_time">1481619893000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
          <collectionProp name="Arguments.arguments">
            <elementProp name="CsvSMS1" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS1</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="CsvSMS2" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS2</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="ErrorCode" elementType="Argument">
              <stringProp name="Argument.name">ErrorCode</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="Analysis" elementType="Argument">
              <stringProp name="Argument.name">Analysis</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
          </collectionProp>
        </Arguments>
        <hashTree/>
        <CSVDataSet guiclass="TestBeanGUI" testclass="CSVDataSet" testname="CSV Data set config" enabled="true">
          <stringProp name="filename">${CSV path}/BATCH_RESCHEDULE_RECHARGE_PROCESS_NEGATIVE.csv</stringProp>
          <stringProp name="fileEncoding"></stringProp>
          <stringProp name="variableNames"></stringProp>
          <stringProp name="delimiter">,</stringProp>
          <boolProp name="quotedData">false</boolProp>
          <boolProp name="recycle">true</boolProp>
          <boolProp name="stopThread">false</boolProp>
          <stringProp name="shareMode">shareMode.all</stringProp>
        </CSVDataSet>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="File Upload Http Request" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;loginId&quot;:&quot;${LOGIN_ID}&quot;,&quot;password&quot;:&quot;${PASSWORD}&quot;,&quot;data&quot;:{&quot;categoryCode&quot;:&quot;${CATEGORY_CODE}&quot;,&quot;userID&quot;:&quot;${USER_ID}&quot;,&quot;domainCode&quot;:&quot;${DOMAIN_CODE}&quot;,&quot;serviceCode&quot;:&quot;${SERVICE_CODE}&quot;,&quot;scheduleDate&quot;:&quot;${SCHEDULE_DATE}&quot;,&quot;noOfRecords&quot;:&quot;${NO_OF_RECORDS}&quot;,&quot;requestFor&quot;:&quot;${REQUEST_FOR}&quot;,&quot;batchID&quot;:&quot;${BATCH_ID}&quot;,&quot;iterations&quot;:&quot;${ITERATIONS}&quot;,&quot;frequencyCode&quot;:&quot;${FREQUENCY}&quot;,&quot;uploadFilePath&quot;:&quot;${UPLOAD_PATH}&quot;},&quot;type&quot;:&quot;${TYPE}&quot;}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${host}</stringProp>
          <stringProp name="HTTPSampler.port">${port}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol">${protocol}</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${path}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree/>
        <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Request Reader" enabled="true">
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="script">//-- SKD
// -- updating the valiables
var sampler = ctx.getCurrentSampler();
var Arguments = sampler.getArguments();
vars.put(&quot;CsvRequest&quot;,&quot;Request&quot;+Arguments);</stringProp>
        </BeanShellPreProcessor>
        <hashTree/>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Result Writer" enabled="true">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;

String jsonString = prev.getResponseDataAsString();
log.info(&quot;jsonString:&quot;+jsonString);
JSONObject jsonObject = new JSONObject();
JSONParser jsonParser = new JSONParser();

jsonObject = (JSONObject) jsonParser.parse(jsonString);
String statusCodeReq = jsonObject.get(&quot;statusCode&quot;).toString();
String status = jsonObject.get(&quot;status&quot;).toString();
String statusCode = &quot;&quot;;
String TestcaseType = vars.get(&quot;TestcaseType&quot;);
if(statusCodeReq.equalsIgnoreCase(&quot;200&quot;) &amp;&amp; status.equalsIgnoreCase(&quot;true&quot;)){
	statusCode = &quot;Pass&quot;;
}else{
	if(TestcaseType.equalsIgnoreCase(&quot;NEGATIVE&quot;)){
		statusCode = &quot;Pass&quot;;
	}else{
		statusCode = &quot;Fail&quot;;
	}	
}

String TestCaseID = vars.get(&quot;TestcaseId&quot;);//argument name must be same as defined in csv file
String Module = vars.get(&quot;Module&quot;);//argument name must be same as defined in csv file
String Description = vars.get(&quot;Description&quot;);//argument name must be same as defined in csv file
String CsvRequest = vars.get(&quot;CsvRequest&quot;);
String SVNRepositoryID = vars.get(&quot;SVNRepositoryID&quot;);
String LeadName = vars.get(&quot;LeadName&quot;);
String TestFrameworkIP = vars.get(&quot;TestFrameworkIP&quot;);
String TestFrameworkName = vars.get(&quot;TestFrameworkName&quot;);
String TestFrameworkSVNPath = vars.get(&quot;TestFrameworkSVNPath&quot;);
String TestExecutionDateTime = vars.get(&quot;TestExecutionDateTime&quot;);
String ProductInterface = vars.get(&quot;ProductInterface&quot;);
String CsvSMS1 = vars.get(&quot;CsvSMS1&quot;);
String CsvSMS2 = vars.get(&quot;CsvSMS2&quot;);
String ErrorCode= vars.get(&quot;ErrorCode&quot;);
String Analysis= vars.get(&quot;Analysis&quot;);
String DumpData= vars.get(&quot;DumpData&quot;);

log.info(SVNRepositoryID);
log.info(LeadName);
log.info(ProductInterface);
PrintData=&quot;&quot;+SVNRepositoryID+&quot;|&quot;+LeadName+&quot;|&quot;+TestFrameworkIP+&quot;|&quot;+TestFrameworkName+&quot;|&quot;+TestFrameworkSVNPath+&quot;|&quot;+TestExecutionDateTime+&quot;|&quot;+ProductInterface+&quot;|&quot;+TestCaseID+&quot;|&quot;+Module+&quot;|&quot;+Description+&quot;|&quot;+CsvRequest+&quot;|&quot;+jsonString+&quot;|&quot;+DumpData+&quot;|&quot;+CsvSMS1+&quot;|&quot;+CsvSMS2+&quot;|&quot;+statusCode+&quot;|&quot;+ErrorCode;


log.info(PrintData);
String resultcsvpath = vars.get(&quot;ResultCsvPath&quot;);
f = new FileOutputStream(resultcsvpath,  true);
p = new PrintStream(f); 
this.interpreter.setOut(p); 
print(PrintData);
f.close();</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Cancel Schedule Recharge BATCH Positve Scenario" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">0</stringProp>
        <longProp name="ThreadGroup.start_time">1481619822000</longProp>
        <longProp name="ThreadGroup.end_time">1481619822000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
          <collectionProp name="Arguments.arguments">
            <elementProp name="CsvSMS1" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS1</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="CsvSMS2" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS2</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="ErrorCode" elementType="Argument">
              <stringProp name="Argument.name">ErrorCode</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="Analysis" elementType="Argument">
              <stringProp name="Argument.name">Analysis</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
          </collectionProp>
        </Arguments>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Cancel Using batchID http request" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;loginId&quot;:&quot;${loginId}&quot;,&quot;password&quot;:&quot;${password}&quot;,&quot;type&quot;:&quot;${cancelBatch}&quot;,&quot;data&quot;:{&quot;loginId&quot;:&quot;${userLoginID}&quot;,&quot;checklist&quot;:[&quot;${__property(BATCHID)}&quot;]}}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${host}</stringProp>
          <stringProp name="HTTPSampler.port">${port}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol">${protocol}</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${path}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree/>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Result Writer" enabled="false">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.util.List;
import java.util.ArrayList;

import com.univocity.parsers.common.processor.RowListProcessor;
import com.univocity.parsers.csv.CsvParser;
import com.univocity.parsers.csv.CsvParserSettings;
import com.univocity.parsers.csv.CsvWriter;
import com.univocity.parsers.csv.CsvWriterSettings;

JSONObject jsonObject = new JSONObject();
JSONParser jsonParser = new JSONParser();

String jsonString = prev.getResponseDataAsString();

jsonObject = (JSONObject) jsonParser.parse(jsonString);

vars.put(&quot;statusCode&quot;, jsonObject.get(&quot;statusCode&quot;).toString());
vars.put(&quot;status&quot;, jsonObject.get(&quot;status&quot;).toString());


if(vars.get(&quot;statusCode&quot;).equalsIgnoreCase(&quot;200&quot;) &amp;&amp; vars.get(&quot;status&quot;).equalsIgnoreCase(&quot;true&quot;)){
	log.info(&quot;File Path is &gt;&gt;&gt; &quot; + jsonObject.get(&quot;dataObject&quot;).toString());
	vars.put(&quot;downloadedTemplatePath&quot;, jsonObject.get(&quot;dataObject&quot;).toString());
}else{
	log.info(jsonObject.get(&quot;formError&quot;).toString());
}

FileReader fileReader = new FileReader(vars.get(&quot;downloadedTemplatePath&quot;).toString());
CsvParserSettings parserSettings = new CsvParserSettings();
parserSettings.setLineSeparatorDetectionEnabled(true);

RowListProcessor processor = new RowListProcessor();
parserSettings.setProcessor(processor);
parserSettings.setHeaderExtractionEnabled(true);
parserSettings.setSkipEmptyLines(false);
CsvParser parser = new CsvParser(parserSettings);
parser.parse(fileReader);
List rows = new ArrayList();
rows = processor.getRows();

log.info(&quot;Total no of rows is &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot; + rows.size().toString());

File outputFile = new File(vars.get(&quot;downloadedTemplatePath&quot;).toString());

List finalData = new ArrayList();

for (int k = 0; k&lt; rows.size(); k++) {
	String[] row = (String[])rows.get(k);
	int length = row.length+1;
	String[] data = new String[length];
	int min = Integer.parseInt(row[3]);
	int max = Integer.parseInt(row[4]);
	for (int i = 0; i &lt; row.length; i++) {
		data[i] = row[i];
	}
				
	int amount = min + (int)(Math.random() * ((max - min) + 1));
	data[row.length] = Integer.toString(amount);
	finalData.add(data);
}


String[] header = new String[]{&quot;Mobile number*&quot;,&quot;Subscriber ID*&quot;,&quot;Subscriber name*&quot;,&quot;Minimum transaction amount*&quot;,&quot;Maximum transaction amount*&quot;,&quot;Monthly limit*&quot;,&quot;Used limit*&quot;,&quot;Sub-service *&quot;,&quot;Requested amount*&quot;};
		
Writer writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outputFile)));
CsvWriterSettings settings = new CsvWriterSettings();
CsvWriter csvWriter = new CsvWriter(writer, settings);
StringBuilder row = new StringBuilder();
for (String column : header) {
	if (row.length() &gt; 0) {
		row.append(&quot;,&quot;);
	}
	row.append(column);
}
csvWriter.writeRow(row.toString());

for (String[] object : finalData) {
	StringBuilder row2 = new StringBuilder();
	for (String column : object) {
		if (row2.length() &gt; 0) {
			row2.append(&quot;,&quot;);
		}
		row2.append(column);
	}
	csvWriter.writeRow(row2.toString());
}

csvWriter.close();
String inputFileString = vars.get(&quot;downloadedTemplatePath&quot;).toString().replace(&quot;\\&quot;, &quot;/&quot;);
vars.put(&quot;inputFile&quot;, inputFileString);
vars.put(&quot;noOfRecords&quot;, rows.size().toString());</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
        <CSVDataSet guiclass="TestBeanGUI" testclass="CSVDataSet" testname="CSV Data set config" enabled="true">
          <stringProp name="filename">${CSV path}/CANCEL_SCHEDULE_BATCH_DETAIL_POSITIVE.csv</stringProp>
          <stringProp name="fileEncoding"></stringProp>
          <stringProp name="variableNames"></stringProp>
          <stringProp name="delimiter">,</stringProp>
          <boolProp name="quotedData">false</boolProp>
          <boolProp name="recycle">true</boolProp>
          <boolProp name="stopThread">false</boolProp>
          <stringProp name="shareMode">shareMode.all</stringProp>
        </CSVDataSet>
        <hashTree/>
        <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Request Reader" enabled="true">
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="script">//-- SKD
// -- updating the variables
var sampler = ctx.getCurrentSampler();
var Arguments = sampler.getArguments();
vars.put(&quot;CsvRequest&quot;,&quot;Request&quot;+Arguments);</stringProp>
        </BeanShellPreProcessor>
        <hashTree/>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Result Writer" enabled="true">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.JSONArray;


String jsonString = prev.getResponseDataAsString();

JSONObject jsonObject = new JSONObject();
JSONParser jsonParser = new JSONParser();

jsonObject = (JSONObject) jsonParser.parse(jsonString);
String statusCodeReq = jsonObject.get(&quot;statusCode&quot;).toString();
String status = jsonObject.get(&quot;status&quot;).toString();
JSONObject dataObject = jsonObject.get(&quot;dataObject&quot;);
log.info(&quot;here&quot;);
String batch = dataObject.get(&quot;batchID&quot;).toString();

if(statusCodeReq.equalsIgnoreCase(&quot;400&quot;) &amp;&amp; status.equalsIgnoreCase(&quot;false&quot;)){
	statusCode = &quot;Fail&quot;;
}else{
	statusCode = &quot;Pass&quot;;
}
log.info(&quot;here&quot;);

String TestCaseID = vars.get(&quot;TestcaseId&quot;);//argument name must be same as defined in csv file
String Module = vars.get(&quot;Module&quot;);//argument name must be same as defined in csv file
String Description = vars.get(&quot;Description&quot;);//argument name must be same as defined in csv file
String CsvRequest = vars.get(&quot;CsvRequest&quot;);
String SVNRepositoryID = vars.get(&quot;SVNRepositoryID&quot;);
String LeadName = vars.get(&quot;LeadName&quot;);
String TestFrameworkIP = vars.get(&quot;TestFrameworkIP&quot;);
String TestFrameworkName = vars.get(&quot;TestFrameworkName&quot;);
String TestFrameworkSVNPath = vars.get(&quot;TestFrameworkSVNPath&quot;);
String TestExecutionDateTime = vars.get(&quot;TestExecutionDateTime&quot;);
String ProductInterface = vars.get(&quot;ProductInterface&quot;);
String CsvSMS1 = vars.get(&quot;CsvSMS1&quot;);
String CsvSMS2 = vars.get(&quot;CsvSMS2&quot;);
String ErrorCode= vars.get(&quot;ErrorCode&quot;);
String Analysis= vars.get(&quot;Analysis&quot;);
String DumpData= vars.get(&quot;DumpData&quot;);

log.info(SVNRepositoryID);
log.info(LeadName);
log.info(ProductInterface);
PrintData=&quot;&quot;+SVNRepositoryID+&quot;|&quot;+LeadName+&quot;|&quot;+TestFrameworkIP+&quot;|&quot;+TestFrameworkName+&quot;|&quot;+TestFrameworkSVNPath+&quot;|&quot;+TestExecutionDateTime+&quot;|&quot;+ProductInterface+&quot;|&quot;+TestCaseID+&quot;|&quot;+Module+&quot;|&quot;+Description+&quot;|&quot;+CsvRequest+&quot;|&quot;+jsonString+&quot;|&quot;+DumpData+&quot;|&quot;+CsvSMS1+&quot;|&quot;+CsvSMS2+&quot;|&quot;+statusCode+&quot;|&quot;+ErrorCode;


log.info(PrintData);
String resultcsvpath = vars.get(&quot;ResultCsvPath&quot;);
f = new FileOutputStream(resultcsvpath,  true);
p = new PrintStream(f); 
this.interpreter.setOut(p); 
print(PrintData);
f.close();
</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Cancel Schedule Recharge BATCH MSISDN Negative Scenario" enabled="false">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">0</stringProp>
        <longProp name="ThreadGroup.start_time">1481619822000</longProp>
        <longProp name="ThreadGroup.end_time">1481619822000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
          <collectionProp name="Arguments.arguments">
            <elementProp name="CsvSMS1" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS1</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="CsvSMS2" elementType="Argument">
              <stringProp name="Argument.name">CsvSMS2</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="ErrorCode" elementType="Argument">
              <stringProp name="Argument.name">ErrorCode</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="Analysis" elementType="Argument">
              <stringProp name="Argument.name">Analysis</stringProp>
              <stringProp name="Argument.value">null</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
          </collectionProp>
        </Arguments>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Cancel Using batchID http request" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&quot;loginId&quot;:&quot;${loginId}&quot;,&quot;password&quot;:&quot;${password}&quot;,&quot;type&quot;:&quot;${cancelBatch}&quot;,&quot;data&quot;:{&quot;loginId&quot;:&quot;${userLoginID}&quot;,&quot;checklist&quot;:[]}}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${host}</stringProp>
          <stringProp name="HTTPSampler.port">${port}</stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol">${protocol}</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">${path}</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree/>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Result Writer" enabled="false">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.util.List;
import java.util.ArrayList;

import com.univocity.parsers.common.processor.RowListProcessor;
import com.univocity.parsers.csv.CsvParser;
import com.univocity.parsers.csv.CsvParserSettings;
import com.univocity.parsers.csv.CsvWriter;
import com.univocity.parsers.csv.CsvWriterSettings;

JSONObject jsonObject = new JSONObject();
JSONParser jsonParser = new JSONParser();

String jsonString = prev.getResponseDataAsString();

jsonObject = (JSONObject) jsonParser.parse(jsonString);

vars.put(&quot;statusCode&quot;, jsonObject.get(&quot;statusCode&quot;).toString());
vars.put(&quot;status&quot;, jsonObject.get(&quot;status&quot;).toString());


if(vars.get(&quot;statusCode&quot;).equalsIgnoreCase(&quot;200&quot;) &amp;&amp; vars.get(&quot;status&quot;).equalsIgnoreCase(&quot;true&quot;)){
	log.info(&quot;File Path is &gt;&gt;&gt; &quot; + jsonObject.get(&quot;dataObject&quot;).toString());
	vars.put(&quot;downloadedTemplatePath&quot;, jsonObject.get(&quot;dataObject&quot;).toString());
}else{
	log.info(jsonObject.get(&quot;formError&quot;).toString());
}

FileReader fileReader = new FileReader(vars.get(&quot;downloadedTemplatePath&quot;).toString());
CsvParserSettings parserSettings = new CsvParserSettings();
parserSettings.setLineSeparatorDetectionEnabled(true);

RowListProcessor processor = new RowListProcessor();
parserSettings.setProcessor(processor);
parserSettings.setHeaderExtractionEnabled(true);
parserSettings.setSkipEmptyLines(false);
CsvParser parser = new CsvParser(parserSettings);
parser.parse(fileReader);
List rows = new ArrayList();
rows = processor.getRows();

log.info(&quot;Total no of rows is &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot; + rows.size().toString());

File outputFile = new File(vars.get(&quot;downloadedTemplatePath&quot;).toString());

List finalData = new ArrayList();

for (int k = 0; k&lt; rows.size(); k++) {
	String[] row = (String[])rows.get(k);
	int length = row.length+1;
	String[] data = new String[length];
	int min = Integer.parseInt(row[3]);
	int max = Integer.parseInt(row[4]);
	for (int i = 0; i &lt; row.length; i++) {
		data[i] = row[i];
	}
				
	int amount = min + (int)(Math.random() * ((max - min) + 1));
	data[row.length] = Integer.toString(amount);
	finalData.add(data);
}


String[] header = new String[]{&quot;Mobile number*&quot;,&quot;Subscriber ID*&quot;,&quot;Subscriber name*&quot;,&quot;Minimum transaction amount*&quot;,&quot;Maximum transaction amount*&quot;,&quot;Monthly limit*&quot;,&quot;Used limit*&quot;,&quot;Sub-service *&quot;,&quot;Requested amount*&quot;};
		
Writer writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outputFile)));
CsvWriterSettings settings = new CsvWriterSettings();
CsvWriter csvWriter = new CsvWriter(writer, settings);
StringBuilder row = new StringBuilder();
for (String column : header) {
	if (row.length() &gt; 0) {
		row.append(&quot;,&quot;);
	}
	row.append(column);
}
csvWriter.writeRow(row.toString());

for (String[] object : finalData) {
	StringBuilder row2 = new StringBuilder();
	for (String column : object) {
		if (row2.length() &gt; 0) {
			row2.append(&quot;,&quot;);
		}
		row2.append(column);
	}
	csvWriter.writeRow(row2.toString());
}

csvWriter.close();
String inputFileString = vars.get(&quot;downloadedTemplatePath&quot;).toString().replace(&quot;\\&quot;, &quot;/&quot;);
vars.put(&quot;inputFile&quot;, inputFileString);
vars.put(&quot;noOfRecords&quot;, rows.size().toString());</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
        <CSVDataSet guiclass="TestBeanGUI" testclass="CSVDataSet" testname="CSV Data set config" enabled="true">
          <stringProp name="filename">${CSV path}/CANCEL_SCHEDULE_BATCH_DETAIL_NEGATIVE.csv</stringProp>
          <stringProp name="fileEncoding"></stringProp>
          <stringProp name="variableNames"></stringProp>
          <stringProp name="delimiter">,</stringProp>
          <boolProp name="quotedData">false</boolProp>
          <boolProp name="recycle">true</boolProp>
          <boolProp name="stopThread">false</boolProp>
          <stringProp name="shareMode">shareMode.all</stringProp>
        </CSVDataSet>
        <hashTree/>
        <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="Request Reader" enabled="true">
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="script">//-- SKD
// -- updating the variables
var sampler = ctx.getCurrentSampler();
var Arguments = sampler.getArguments();
vars.put(&quot;CsvRequest&quot;,&quot;Request&quot;+Arguments);</stringProp>
        </BeanShellPreProcessor>
        <hashTree/>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="Result Writer" enabled="true">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.JSONArray;


String jsonString = prev.getResponseDataAsString();

JSONObject jsonObject = new JSONObject();
JSONParser jsonParser = new JSONParser();

jsonObject = (JSONObject) jsonParser.parse(jsonString);
String statusCodeReq = jsonObject.get(&quot;statusCode&quot;).toString();
String status = jsonObject.get(&quot;status&quot;).toString();
JSONObject dataObject = (JSONArray) jsonObject.get(&quot;dataObject&quot;);


String statusCode = &quot;&quot;;
if(statusCodeReq.equalsIgnoreCase(&quot;400&quot;) &amp;&amp; status.equalsIgnoreCase(&quot;false&quot;)){
	statusCode = &quot;Pass&quot;;
}else{
	statusCode = &quot;Fail&quot;;
}

String TestCaseID = vars.get(&quot;TestcaseId&quot;);//argument name must be same as defined in csv file
String Module = vars.get(&quot;Module&quot;);//argument name must be same as defined in csv file
String Description = vars.get(&quot;Description&quot;);//argument name must be same as defined in csv file
String CsvRequest = vars.get(&quot;CsvRequest&quot;);
String SVNRepositoryID = vars.get(&quot;SVNRepositoryID&quot;);
String LeadName = vars.get(&quot;LeadName&quot;);
String TestFrameworkIP = vars.get(&quot;TestFrameworkIP&quot;);
String TestFrameworkName = vars.get(&quot;TestFrameworkName&quot;);
String TestFrameworkSVNPath = vars.get(&quot;TestFrameworkSVNPath&quot;);
String TestExecutionDateTime = vars.get(&quot;TestExecutionDateTime&quot;);
String ProductInterface = vars.get(&quot;ProductInterface&quot;);
String CsvSMS1 = vars.get(&quot;CsvSMS1&quot;);
String CsvSMS2 = vars.get(&quot;CsvSMS2&quot;);
String ErrorCode= vars.get(&quot;ErrorCode&quot;);
String Analysis= vars.get(&quot;Analysis&quot;);
String DumpData= vars.get(&quot;DumpData&quot;);

log.info(SVNRepositoryID);
log.info(LeadName);
log.info(ProductInterface);
PrintData=&quot;&quot;+SVNRepositoryID+&quot;|&quot;+LeadName+&quot;|&quot;+TestFrameworkIP+&quot;|&quot;+TestFrameworkName+&quot;|&quot;+TestFrameworkSVNPath+&quot;|&quot;+TestExecutionDateTime+&quot;|&quot;+ProductInterface+&quot;|&quot;+TestCaseID+&quot;|&quot;+Module+&quot;|&quot;+Description+&quot;|&quot;+CsvRequest+&quot;|&quot;+jsonString+&quot;|&quot;+DumpData+&quot;|&quot;+CsvSMS1+&quot;|&quot;+CsvSMS2+&quot;|&quot;+statusCode+&quot;|&quot;+ErrorCode;


log.info(PrintData);
String resultcsvpath = vars.get(&quot;ResultCsvPath&quot;);
f = new FileOutputStream(resultcsvpath,  true);
p = new PrintStream(f); 
this.interpreter.setOut(p); 
print(PrintData);
f.close();

</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Convert csv to xls" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <longProp name="ThreadGroup.start_time">1490081607000</longProp>
        <longProp name="ThreadGroup.end_time">1490081607000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <BeanShellSampler guiclass="BeanShellSamplerGui" testclass="BeanShellSampler" testname="BeanShell Sampler" enabled="true">
          <stringProp name="BeanShellSampler.query"></stringProp>
          <stringProp name="BeanShellSampler.filename"></stringProp>
          <stringProp name="BeanShellSampler.parameters"></stringProp>
          <boolProp name="BeanShellSampler.resetInterpreter">false</boolProp>
        </BeanShellSampler>
        <hashTree>
          <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <boolProp name="resetInterpreter">false</boolProp>
            <stringProp name="script">import com.comviva.CSVToExcelConverter;
import org.apache.jmeter.util.JMeterUtils;

String value=JMeterUtils.getPropDefault(&quot;name&quot;,&quot;&quot;);

try {
    //your code here
    //String[] paths = {&quot;C:\\FINAL\\AddUserO2c.csv&quot;, &quot;C:\\FINAL\\abc.xls&quot;};
CSVToExcelConverter object = new CSVToExcelConverter();
log.info(&quot;asad11&quot;);
String resultcsvpath = vars.get(&quot;ResultCsvPath&quot;);
String resultxlspath = vars.get(&quot;ResultXlsPath&quot;);

log.info(resultcsvpath);
object.convertCsvToXLS(resultcsvpath, resultxlspath);
log.info(&quot;asad11&quot;);
}
catch (Throwable ex) {
    log.error(&quot;Error in Beanshell&quot;, ex);
    throw ex;
}
</stringProp>
          </BeanShellPostProcessor>
          <hashTree/>
          <DebugPostProcessor guiclass="TestBeanGUI" testclass="DebugPostProcessor" testname="Debug PostProcessor" enabled="true">
            <boolProp name="displayJMeterProperties">false</boolProp>
            <boolProp name="displayJMeterVariables">true</boolProp>
            <boolProp name="displaySamplerProperties">true</boolProp>
            <boolProp name="displaySystemProperties">false</boolProp>
          </DebugPostProcessor>
          <hashTree/>
        </hashTree>
      </hashTree>
    </hashTree>
  </hashTree>
</jmeterTestPlan>
